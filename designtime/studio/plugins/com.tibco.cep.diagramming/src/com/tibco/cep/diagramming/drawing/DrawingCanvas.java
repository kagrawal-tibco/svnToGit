package com.tibco.cep.diagramming.drawing;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.Timer;

import com.tomsawyer.graphicaldrawing.TSEGraphManager;
import com.tomsawyer.interactive.swing.TSSwingCanvas;


public class DrawingCanvas extends TSSwingCanvas implements ActionListener {

	/**
	 * @author ggrigore 
	 */
	private static final long serialVersionUID = 1L;
	private boolean needsFitInCanvas = true;
	public static final int INHERITANCE_LINK_TYPE = 1;
	public static final int REFERENCE_LINK_TYPE = 2;
	public static final int CONTAINMENT_LINK_TYPE = 3;

	/**
	 * This is a utility timer that causes <code>onTimer</code> to be
	 * called regularly.
	 */
	Timer timer;

	/**
	 * This flag indicates that the invalid regions of the swing canvas
	 * need to be redrawn and repainted at the next timer tick.
	 */
	boolean updateOnTimerRequested;	


	public DrawingCanvas(TSEGraphManager gMgr) {
		super(gMgr);
		needsFitInCanvas = true;
		this.timer = new Timer(this.getDefaultTimerDelay(), this);
		this.timer.start();	        
	}

	public DrawingCanvas(TSEGraphManager gMgr, boolean withScrollbars) {
		super(gMgr, withScrollbars);
		needsFitInCanvas = true;
		this.timer = new Timer(this.getDefaultTimerDelay(), this);
		this.timer.start();	
	}

	public void onResize(int width, int height) {
		super.onResize(width, height);

		if (needsFitInCanvas) {
			if (width > 10 && height > 10)
			{
				fitInCanvas(true);

				// It used to be that we had to do a fit in canvas later if
				// the BE top level frame was made visible and valid too late
				/*
	                SwingUtilities.invokeLater(new Runnable()
	                {
	                    public void run()
	                    {
	                        fitInCanvas(true);
	                    }
	                });
				 */	                

				needsFitInCanvas = false;
			}
		}
		else
		{
			repaint();
		}
	}

	// ---------------------------------------------------------------------
	// Section: Timer
	// ---------------------------------------------------------------------

	/**
	 * This method returns the default timer interval, in milliseconds.
	 * @return 100
	 */
	public int getDefaultTimerDelay() {
		return 100;
	}


	public void setTimerDelay(int delay) {
		this.timer.setDelay(delay);
	}


	public int getTimerDelay() {
		return this.timer.getDelay();
	}

	public void addTimerListener(ActionListener listener) {
		this.timer.addActionListener(listener);
	}

	public void removeTimerListener(ActionListener listener) {
		this.timer.removeActionListener(listener);
	}


	/**
	 * This method returns whether or not the input event was generated by
	 * the timer of this swing canvas.
	 */
	public boolean isTimerEvent(ActionEvent event)	{
		return ((event != null) &&
				(event.getSource() == this.timer));
	}


	public void startTimer() {
		if (!this.isTimerRunning()) 	{
			this.timer.start();
		}
	}

	public boolean isTimerRunning() {
		return this.timer.isRunning();
	}

	public boolean stopTimer() 	{
		boolean timerRunning = this.isTimerRunning();

		if (timerRunning) {
			this.timer.stop();
		}

		return timerRunning;
	}


	/**
	 * This method causes the invalid region of the canvas
	 * to be redrawn and repainted on the next timer tick.
	 */
	public void requestUpdateOnTimer() {
		this.updateOnTimerRequested = true;
	}


	/**
	 * This method is called every time the timer fires.
	 * If an update is pending, (i.e. <code>requestUpdateOnTimer</code>
	 * has been called since the last timer tick) it updates
	 * the canvas's invalid region and repaints it to the
	 * screen. Users can override this for custom timer behavior.
	 */
	public void onTimer() {
		if (this.updateOnTimerRequested) {
			this.updateInvalidRegion(true);
			this.updateOnTimerRequested = false;
		}
	}

	public void actionPerformed(ActionEvent event) 	{
		if (this.isTimerEvent(event)) {
			this.onTimer();
		}
	}

	public void dispose() {
		this.doubleBuffer = null;
		this.stopTimer();
		this.stopAnimator();
		this.isAnimating();
		this.getCommandManager().clearUndoHistory();
		this.getCommandManager().getEventManager().removeAllListeners(this);
		this.getCommandManager().getEventManager().removeAllListeners(this.getGraphManager());
		this.removeAll();
//		TSAnimationManagerImpl instance = (TSAnimationManagerImpl) TSAnimationManager.getInstance();
//		Field[] declaredFields = instance.getClass().getDeclaredFields();
//		for (Field field : declaredFields) {
//			if ("animatorEventListeners".equals(field.getName())) {
//				field.isAccessible();
//				field.setAccessible(true);
//				
//				try {
//					Object object = field.get(instance);
//					if (object instanceof Map) {
//						Map listeners = (Map) object;
//						Object[] array = listeners.keySet().toArray();
//						for (Object obj : array) {
//							TSAnimationEventListener listener = (TSAnimationEventListener) obj;
////							TSBaseCanvasInterface swingCanvas = listener.getSwingCanvas();
//							if (listener != null) {
//								System.out.println("swing canvas");
////								TSAnimationManager.unregisterAnimatorEventListener(listener);
//							}
//						}
//					}
//				} catch (IllegalArgumentException e) {
//					e.printStackTrace();
//				} catch (IllegalAccessException e) {
//					e.printStackTrace();
//				}
//			}
//		}
	}
	
}
