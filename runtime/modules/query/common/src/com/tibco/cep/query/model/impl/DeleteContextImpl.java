package com.tibco.cep.query.model.impl;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.antlr.runtime.tree.CommonTree;

import com.tibco.cep.query.exception.DuplicateAliasException;
import com.tibco.cep.query.model.DeleteContext;
import com.tibco.cep.query.model.FromClause;
import com.tibco.cep.query.model.ModelContext;
import com.tibco.cep.query.model.NamedDeleteContext;
import com.tibco.cep.query.model.ProjectContext;
import com.tibco.cep.query.model.QueryContext;
import com.tibco.cep.query.model.WhereClause;
import com.tibco.cep.query.model.visitor.HierarchicalContextVisitor;
import com.tibco.cep.query.model.visitor.impl.ContextResolutionVisitor;

/**
 * Base implementation for SelectContext.
 */
public class DeleteContextImpl
        extends AbstractQueryContext implements DeleteContext {

    private Map<Object,  ModelContext> contextMap = new HashMap<Object,  ModelContext>();
    protected ProjectContext projectContext;
    private String alias;
    protected Object first;
    protected Object offset;
    private boolean isPseudoAliased;


    public DeleteContextImpl(ModelContext parentContext, String alias, CommonTree tree) throws Exception {
        super(parentContext, tree);
        if (null == alias) {
            this.setAlias(this.getRootContext().getIdGenerator().nextIdentifier().toString(), true);
        } else {
            this.setAlias(alias, false);
        }
        this.first = null;
        this.offset = null;        
    }

     public DeleteContextImpl(ModelContext parentContext, CommonTree tree) throws Exception  {
        this (parentContext, null, tree);
    }

    /**
     * @return the Alias
     */
    public String getAlias() {
        return this.alias;
    }

    /**
     * @return if the alias is a pseudo alias
     */
    public boolean isPseudoAliased() {
        return this.isPseudoAliased;
    }

    /**
     * sets the alias and if it is generated by the system
     *
     * @param alias           String
     * @param isPseudoAliased boolean
     */
    public void setAlias(String alias, boolean isPseudoAliased) throws DuplicateAliasException {
        final Object previousModelContext = ((NamedDeleteContext) this.getRootContext()).getModelContextByAlias(alias);
        if ((null != previousModelContext) && (this != previousModelContext)) {
            throw new DuplicateAliasException(this);
        }

        if (null != this.alias) {
            this.getContextMap().remove(this.alias); // old alias
        }
        if (null != alias) {
            this.getContextMap().put(alias, this); // new alias
        }
        this.alias = alias;
        this.isPseudoAliased = isPseudoAliased;
    }


    public ProjectContext getProjectContext() {
        return this.projectContext;
    }


    /**
     * @return the fromClause
     */
    public FromClause getFromClause() {
        // From clause
        final ModelContext[] children = this.getDescendantContextsByType(this, ModelContext.CTX_TYPE_FROM);
        if ((null != children) && (children.length >= 1)) {
            from = (FromClauseImpl) children[0];
        }
        return from;        
    }

    /**
     * Returns the WHERE clause from the Select context
     *
     * @return WhereClause
     */
    public WhereClause getWhereClause() {
        // Where clause
        final List<ModelContext> whereChildren = this.getDirectDescendantContextsByType(ModelContext.CTX_TYPE_WHERE);
        if ((null != whereChildren) && (whereChildren.size() >= 1)) {
            where = (WhereClause) whereChildren.get(0);
        }
        return where;
    }

    public ModelContext getContext() {
        return this;
    }


    public int getContextType() {
        return ModelContext.CTX_TYPE_DELETE;
    }


    public Map<Object,ModelContext> getContextMap() {
        return this.contextMap;
    }


    public void initialize() throws Exception {
        // TODO Auto-generated method stub
    }

    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof DeleteContextImpl)) {
            return false;
        }
        if (this.getClass().isAssignableFrom(o.getClass()) && !this.getClass().equals(o.getClass())) {
            return o.equals(this); // Delegates to most specific class.
        }

        final DeleteContextImpl that = (DeleteContextImpl) o;

        return (((null == this.first) && (null == that.first)) || ((null != this.first) && (this.first.equals(that.first))))
                && (((null == this.offset) && (null == that.offset)) || ((null != this.offset) && (this.offset.equals(that.offset))))
                && this.childContext.equals(that.childContext);
    }

    public int hashCode() {
        long longHash = (null == this.first) ? 0 : this.first.hashCode();
        longHash = 29 * longHash + ((null == this.offset) ? 0 : this.offset.hashCode());
        longHash ^= (longHash >>> 32);
        longHash ^= (longHash >>> 32);
        longHash = 29 * longHash + this.childContext.hashCode();
        longHash ^= (longHash >>> 32);
        return (int) longHash;
    }

    /**
     * Overrides the standards visitor pattern's accept to resolve in necessary order.
     *
     * @param v HierarchicalContextVisitor
     * @return boolean
     */
    public boolean accept(HierarchicalContextVisitor v) throws Exception {

        // Forces accept() of some children to be called in appropriate order in case of resolution.
        if (v instanceof ContextResolutionVisitor) {

            this.getFromClause().accept(v);

            QueryContext qc = this.getWhereClause();
            if (null != qc) {
                qc.accept(v);
            }
        }

        // Accepts everything else and eventually this.
        return super.accept(v);
    }
}