package com.tibco.cep.query.model.impl;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.antlr.runtime.tree.CommonTree;

import com.tibco.cep.query.exception.DuplicateAliasException;
import com.tibco.cep.query.model.BindVariable;
import com.tibco.cep.query.model.DistinctClause;
import com.tibco.cep.query.model.FromClause;
import com.tibco.cep.query.model.GroupClause;
import com.tibco.cep.query.model.ModelContext;
import com.tibco.cep.query.model.NamedSelectContext;
import com.tibco.cep.query.model.OrderClause;
import com.tibco.cep.query.model.ProjectContext;
import com.tibco.cep.query.model.ProjectionAttributes;
import com.tibco.cep.query.model.QueryContext;
import com.tibco.cep.query.model.SelectContext;
import com.tibco.cep.query.model.WhereClause;
import com.tibco.cep.query.model.visitor.HierarchicalContextVisitor;
import com.tibco.cep.query.model.visitor.impl.ContextResolutionVisitor;

/**
 * Base implementation for SelectContext.
 */
public class SelectContextImpl
        extends AbstractQueryContext implements SelectContext {

    private Map<Object,  ModelContext> contextMap = new HashMap<Object,  ModelContext>();
    protected ProjectContext projectContext;
    private String alias;
    protected Object first;
    protected Object offset;
    private boolean isPseudoAliased;
    private boolean isPartOfExists;


    public SelectContextImpl(ModelContext parentContext, String alias, boolean isPartOfExists,
                             CommonTree tree) throws Exception {
        super(parentContext, tree);
        if (null == alias) {
            this.setAlias(this.getRootContext().getIdGenerator().nextIdentifier().toString(), true);
        } else {
            this.setAlias(alias, false);
        }
        this.isPartOfExists = isPartOfExists;
        this.first = null;
        this.offset = null;
    }

     public SelectContextImpl(ModelContext parentContext, boolean isPartOfExists,
                              CommonTree tree) throws Exception  {
        this (parentContext, null, isPartOfExists,  tree);
    }

    /**
     * @return the Alias
     */
    public String getAlias() {
        return this.alias;
    }

    /**
     * @return if the alias is a pseudo alias
     */
    public boolean isPseudoAliased() {
        return this.isPseudoAliased;
    }

    /**
     * sets the alias and if it is generated by the system
     *
     * @param alias           String
     * @param isPseudoAliased boolean
     */
    public void setAlias(String alias, boolean isPseudoAliased) throws DuplicateAliasException {
        final Object previousModelContext = ((NamedSelectContext) this.getRootContext()).getModelContextByAlias(alias);
        if ((null != previousModelContext) && (this != previousModelContext)) {
            throw new DuplicateAliasException(this);
        }

        if (null != this.alias) {
            this.getContextMap().remove(this.alias); // old alias
        }
        if (null != alias) {
            this.getContextMap().put(alias, this); // new alias
        }
        this.alias = alias;
        this.isPseudoAliased = isPseudoAliased;
    }


    public ProjectContext getProjectContext() {
        return this.projectContext;
    }


    /**
     * @return the fromClause
     */
    public FromClause getFromClause() {
        final ModelContext[] children = this.getDescendantContextsByType(this, ModelContext.CTX_TYPE_FROM);
        if ((null == children) || (children.length < 1)) {
            return null;
        }
        return (FromClauseImpl) children[0];
    }

    /**
     * Returns the WHERE clause from the Select context
     *
     * @return WhereClause
     */
    public WhereClause getWhereClause() {
        final List<ModelContext> children = this.getDirectDescendantContextsByType(ModelContext.CTX_TYPE_WHERE);
        if ((null == children) || (children.size() < 1)) {
            return null;
        }
        return (WhereClause) children.get(0);
    }

    /**
     * Returns the GROUP BY clause from the Select context
     *
     * @return GroupClause
     */
    public GroupClause getGroupClause() {
        final ModelContext[] children = this.getDescendantContextsByType(this, ModelContext.CTX_TYPE_GROUP_CLAUSE);
        if ((null == children) || (children.length < 1)) {
            return null;
        }
        return (GroupClause) children[0];
    }

    /**
     * Returns the ORDER BY clause from the Select context
     *
     * @return GroupClause
     */
    public OrderClause getOrderClause() {
        final ModelContext[] children = this.getDescendantContextsByType(this, ModelContext.CTX_TYPE_ORDER_CLAUSE);
        if ((null == children) || (children.length < 1)) {
            return null;
        }
        return (OrderClause) children[0];
    }


    /**
     * @return the projectionAttributes
     */
    public ProjectionAttributes getProjectionAttributes() {
        final ModelContext[] children = this.getDescendantContextsByType(this, ModelContext.CTX_TYPE_PROJECTION_ATTRIBUTES);
        if ((null == children) || (children.length < 1)) {
            return null;
        }
        return (ProjectionAttributes) children[0];
    }


    public ModelContext getContext() {
        return this;
    }


    public int getContextType() {
        return ModelContext.CTX_TYPE_SELECT;
    }


    public Map<Object,ModelContext> getContextMap() {
        return this.contextMap;
    }


    public void initialize() throws Exception {
        // TODO Auto-generated method stub
    }

    /**
     * returns the first number of tuples from a given offset
     *
     * @return Object evaluating to the number of tuples
     */
    public Object getLimitFirst() {
        return this.first;
    }

    /**
     * Returns the offset number of tuple from where the first count of tuples are selected,
     * the default value is 0
     *
     * @return Object evaluating to the offset number of tuples
     */
    public Object getLimitOffset() {
        return this.offset;
    }

    /**
     * Sets the first number of tuples
     *
     * @param first Integer value of the first number of tuples
     */
    public void setLimitFirst(Integer first) {
        this.first = first;
    }

    /**
     * Sets the offset from which the tuples should be counted
     *
     * @param offset Integer value of the offset number of tuples
     */
    public void setLimitOffset(Integer offset) {
        this.offset = offset;
    }

    /**
     * Sets the first number of tuples
     *
     * @param first BindVariable evaluating to the number of tuples
     */
    public void setLimitFirst(BindVariable first) {
        this.first = first;
    }

    /**
     * Sets the offset from which the tuples should be counted
     *
     * @param offset BindVariable evaluating to the offset number of tuples
     */
    public void setLimitOffset(BindVariable offset) {
        this.offset = offset;
    }



    /**
     * Returns the DISTINCT clause context from the Select Context if any
     *
     * @return DistinctClause of the modelcontext if any, else null
     */
    public DistinctClause getDistinctClause() {
        final ModelContext[] children = this.getDescendantContextsByType(this, ModelContext.CTX_TYPE_DISTINCT_CLAUSE);
        if ((null == children) || (children.length < 1)) {
            return null;
        }
        return (DistinctClause) children[0];
    }


    /**
     * Returns true if the tuples are distinct else false
     *
     * @return boolean true or false
     */
    public boolean isDistinct() {
        final ModelContext[] children = this.getDescendantContextsByType(this, ModelContext.CTX_TYPE_FROM);
        return (null != children) && (children.length > 0);
    }


    /**
     * Returns true if the select is part of of an EXISTS clause
     *
     * @return boolean true or false
     */
    public boolean isPartOfExists() {
        return this.isPartOfExists;
    }

    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof SelectContextImpl)) {
            return false;
        }
        if (this.getClass().isAssignableFrom(o.getClass()) && !this.getClass().equals(o.getClass())) {
            return o.equals(this); // Delegates to most specific class.
        }

        final SelectContextImpl that = (SelectContextImpl) o;

        return (((null == this.first) && (null == that.first)) || ((null != this.first) && (this.first.equals(that.first))))
                && (((null == this.offset) && (null == that.offset)) || ((null != this.offset) && (this.offset.equals(that.offset))))
                && (this.isDistinct() == that.isDistinct())
                && this.childContext.equals(that.childContext);
    }

    public int hashCode() {
        long longHash = (null == this.first) ? 0 : this.first.hashCode();
        longHash = 29 * longHash + ((null == this.offset) ? 0 : this.offset.hashCode());
        longHash ^= (longHash >>> 32);
        longHash = 29 * longHash + (this.isDistinct() ? 1 : 0);
        longHash ^= (longHash >>> 32);
        longHash = 29 * longHash + this.childContext.hashCode();
        longHash ^= (longHash >>> 32);
        return (int) longHash;
    }

    /**
     * Overrides the standards visitor pattern's accept to resolve in necessary order.
     *
     * @param v HierarchicalContextVisitor
     * @return boolean
     */
    public boolean accept(HierarchicalContextVisitor v) throws Exception {

        // Forces accept() of some children to be called in appropriate order in case of resolution.
        if (v instanceof ContextResolutionVisitor) {

            this.getFromClause().accept(v);

            QueryContext qc = this.getWhereClause();
            if (null != qc) {
                qc.accept(v);
            }

            qc = this.getGroupClause();
            if (null != qc) {
                qc.accept(v);
            }

            this.getProjectionAttributes().accept(v);

            qc = this.getOrderClause();
            if (null != qc) {
                qc.accept(v);
            }
        }

        // Accepts everything else and eventually this.
        return super.accept(v);
    }
}
