
package com.tibco.cep.query.model.impl;

import java.util.Arrays;
import java.util.Iterator;

import org.antlr.runtime.tree.CommonTree;

import com.tibco.cep.query.exception.DuplicateAliasException;
import com.tibco.cep.query.model.Expression;
import com.tibco.cep.query.model.ModelContext;
import com.tibco.cep.query.model.Projection;
import com.tibco.cep.query.model.TypeInfo;
import com.tibco.cep.query.model.TypedContext;

/**
 * @author pdhar
 *
 */
public abstract class AbstractProjection extends AbstractQueryContext implements
        Projection {

    protected boolean isResolved;
    private boolean isPseudoAliased = false;
    private String  alias = null;



    /**
     * @param context
     * @param tree
     */
    public AbstractProjection(ModelContext context, CommonTree tree) {
        super(context, tree);
    }


    /**
     * @return the Alias
     */
    public String getAlias() {
        return this.alias;
    }


    /**
     * @return if the alias is a pseudo alias
     */
    public boolean isPseudoAliased() {
        return this.isPseudoAliased;
    }


    /**
     * sets the alias and if it is generated by the system
     *
     * @param alias
     */
    public void setAlias(String alias, boolean isPseudoAliased) throws DuplicateAliasException {
        if ((null != alias) && !alias.equals(this.alias)) {
            for (Object k : this.getContextMap().keySet()) {
                if (alias.equals(k)) {
                    throw new DuplicateAliasException(this);
                }
            }
        }
        this.alias = alias;
        this.isPseudoAliased = isPseudoAliased;
        this.getContextMap().put(alias, this);
    }



    public Projection getProjection(String alias) throws Exception {
        for (Iterator iter = getChildrenIterator(); iter.hasNext();) {
            Projection element = (Projection) iter.next();
            if(element.getAlias().equals(alias)) {
                return element;
            }
        }
        return null;
    }

    public Projection[] getProjections() throws Exception {
        return Arrays.asList(getChildren()).toArray(new Projection[0]);
    }


    public int getContextType() {
        return ModelContext.CTX_TYPE_PROJECTION;
    }


    public boolean isResolved() {
       return this.isResolved;
   }


    /**
     * @return TypeInfo the type information of the context
     */
    public TypeInfo getTypeInfo() throws Exception {
        return ((TypedContext) this.getExpression()).getTypeInfo();
    }


    /**
     * @return ModelContext the identified context
     */
    public Expression getExpression() {
        return (Expression) this.getChildrenIterator().next();
    }


    public String getProjectionText() {
        return tree.getText();
    }

    public String toString() {
        return "{" + this.getAlias() + "=" + this.getExpression() + "}";
    }


    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof ModelContext)) {
            return false;
        }
        if (this.getClass().isAssignableFrom(o.getClass()) && !this.getClass().equals(o.getClass())) {
            return o.equals(this); // Delegates to most specific class.
        }

        final AbstractProjection that = (AbstractProjection) o;
        if (!(this.alias.equals(that.alias) && (this.isPseudoAliased == that.isPseudoAliased))) {
            return false;
        }
        final Expression thisExpr = this.getExpression();
        final Expression thatExpr = that.getExpression();
        return (thisExpr == thatExpr)
                || ((null != thisExpr) && thisExpr.equals(thatExpr));

    }


    public int hashCode() {
        return ((this.isPseudoAliased ? 1 : 0) * 27
                + this.getExpression().hashCode()) * 27
                + this.getAlias().hashCode();
    }

}
