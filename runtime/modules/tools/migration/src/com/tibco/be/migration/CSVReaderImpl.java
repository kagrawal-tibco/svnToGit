package com.tibco.be.migration;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.PushbackReader;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/*
 * Author: Ashwin Jayaprakash Date: Feb 25, 2008 Time: 1:31:43 PM
 */

/**
 * Reads the CSV file that is generated by {@link CSVWriterImpl}.
 */
public class CSVReaderImpl implements CSVReader, Constants {
    protected final String fileEncoding;

    protected final String inputDirectory;

    protected final String inputFileNamePrefix;

    File[] mainFragments;

    int fragmentIndex;

    Helper helper;

    /**
     * @param inputDirectory
     * @param inputFileNamePrefix
     * @param fileEncoding
     * @throws IOException
     */
    public CSVReaderImpl(String inputDirectory, String inputFileNamePrefix, String fileEncoding)
            throws IOException {
        this.fileEncoding = fileEncoding;
        this.inputDirectory = inputDirectory;
        this.inputFileNamePrefix = inputFileNamePrefix;

        init();
    }

    /**
     * @param inputDirectory
     * @param inputFileNamePrefix
     * @throws IOException
     */
    public CSVReaderImpl(String inputDirectory, String inputFileNamePrefix) throws IOException {
        this(inputDirectory, inputFileNamePrefix, DEFAULT_FILE_ENCODING);
    }

    private void init() throws IOException {
        this.mainFragments = getSortedFragmentFiles();
        this.fragmentIndex = 0;

        this.helper = new Helper();

        this.helper.init(mainFragments[fragmentIndex], fileEncoding);
    }

    public String[] nextRow() throws IOException {
        boolean hasRow = helper.tryAndMoveToNextRow();

        if (hasRow == false) {
            // Close current fragment.
            helper.discard();

            if (fragmentIndex + 1 < mainFragments.length) {
                // Read the next fragment.
                fragmentIndex++;
                helper.init(mainFragments[fragmentIndex], fileEncoding);

                hasRow = helper.tryAndMoveToNextRow();
            }
        }

        // Still no new row.
        if (hasRow == false) {
            return null;
        }

        return helper.currentRow;
    }

    public void close() throws Exception {
        mainFragments = null;

        helper.discard();
        helper = null;
    }

    // ----------

    private File[] getSortedFragmentFiles() throws IOException {
        final File directory = new File(inputDirectory);

        if (directory.exists() == false || directory.isDirectory() == false) {
            throw new IOException("Directory: " + directory.getAbsolutePath() + " does not exist.");
        }

        String regEx = Pattern.quote(inputFileNamePrefix) + "(\\.([0-9]+))*" + MAIN_FILE_EXTENSION;
        final Pattern pattern = Pattern.compile(regEx);
        final TreeMap sortedFileNumAndFiles = new TreeMap();

        directory.listFiles(new FilenameFilter() {
            public boolean accept(File dir, String name) {
                if (dir == directory || dir.equals(directory)) {
                    Matcher matcher = pattern.matcher(name);
                    if (matcher.matches()) {
                        String index = matcher.group(2);

                        int i = 0;
                        // Not main file.
                        if (index != null && index.length() > 0) {
                            i = Integer.parseInt(index);
                        }

                        sortedFileNumAndFiles.put(new Integer(i), new File(dir, name));
                    }
                }

                return false;
            }
        });

        if (sortedFileNumAndFiles.size() == 0) {
            throw new IOException("Files with prefix: " + inputFileNamePrefix
                    + " could not be located.");
        }

        File[] fragments = new File[sortedFileNumAndFiles.size()];
        for (int i = 0; i < fragments.length; i++) {
            Integer index = (Integer) sortedFileNumAndFiles.firstKey();
            fragments[i] = (File) sortedFileNumAndFiles.remove(index);
        }

        if (fragments.length == 0) {
            throw new IOException("Files matching the pattern: " + regEx
                    + " could not be located in: " + directory.getAbsolutePath());
        }

        for (int i = 0; i < fragments.length; i++) {
            if (fragments[i].canRead() == false) {
                throw new IOException("File: " + fragments[i] + " cannot be read.");
            }
        }

        return fragments;
    }

    // ---------

    protected static class Helper {
        String fileEncoding;

        File currentFile;

        PushbackReader reader;

        ArrayList stringsInRow;

        String[] currentRow;

        StringBuffer columnContents;

        char[] array;

        void init(File fragment, String fileEncoding) throws UnsupportedEncodingException,
                FileNotFoundException {
            // Choose a small number to make it push-back friendly.
            final int bufferSize = 32;
            reader = new PushbackReader(new BufferedReader(new InputStreamReader(
                    new FileInputStream(fragment), fileEncoding)), bufferSize);

            this.currentFile = fragment;
            this.fileEncoding = fileEncoding;

            stringsInRow = new ArrayList();
            columnContents = new StringBuffer();

            array = new char[bufferSize];
        }

        void discard() {
            stringsInRow.clear();
            stringsInRow = null;

            currentRow = null;

            columnContents.delete(0, columnContents.length());
            columnContents = null;

            fileEncoding = null;
            currentFile = null;
            array = null;

            try {
                reader.close();
            }
            catch (Exception e) {
                // Ignore warning.
                e.printStackTrace(System.err);
            }
            reader = null;
        }

        /**
         * @return <code>true</code> if there is a new row available for reading.
         * @throws IOException
         */
        boolean tryAndMoveToNextRow() throws IOException {
            char[] escapedHexChars = new char[4];
            int currEscapedHexPos = -1;
            int count = 0;
            boolean read1RowFully = false;

            // For each row. Skip comment lines.
            while (true) {
                currentRow = null;
                char prevChar = 0;
                boolean nonNullColumnStarted = false;
                read1RowFully = false;
                boolean commentRow = false;
                int columnCount = 0;
                count = 0;

                while ((count = reader.read(array, 0, array.length)) != -1) {
                    boolean breakFor = false;
                    for (int i = 0; breakFor == false && i < count; i++, columnCount++) {
                        char currChar = array[i];

                        switch (currChar) {
                            case COLUMN_SEPARATOR:
                            case LINE_SEPARATOR:
                                /*
                                 * OOB ref. The column contents can remain
                                 * un-flushed only if it was not within
                                 * start-end markers.
                                 */
                                if (columnContents.length() > 0
                                        && columnContents.indexOf(OUT_OF_BAND_REF_PREFIX, 0) > -1) {
                                    String oobFileRef = columnContents.toString();
                                    replaceCurrentColumnWithOOBData(oobFileRef);

                                    recordAndPurgeCurrentColumn();
                                }
                                // Empty column.
                                else if (prevChar == COLUMN_SEPARATOR) {
                                    recordAndPurgeCurrentColumn();
                                }

                                if (currChar == LINE_SEPARATOR) {
                                    recordAndPurgeCurrentRow();

                                    if (i + 1 < count) {
                                        // Push the extra characters back.
                                        reader.unread(array, i + 1, count - i - 1);
                                    }

                                    read1RowFully = true;

                                    breakFor = true;
                                }

                                break;

                            case NON_NULL_COLUMN_START_END:
                                // This is the end of the start sequence.
                                if (nonNullColumnStarted) {
                                    recordAndPurgeCurrentColumn("");
                                }

                                // Toggle.
                                nonNullColumnStarted = !nonNullColumnStarted;

                                break;

                            case '\\':
                                break;

                            case LINE_SEPARATOR_OPTIONAL_PREFIX:
                                break;

                            default:
                                // Start of escape sequence.
                                if (prevChar == '\\' && currChar == 'u') {
                                    // Start collecting the next few chars.
                                    currEscapedHexPos = 0;
                                }
                                // Escape sequence has already started.
                                else if (currEscapedHexPos >= 0) {
                                    escapedHexChars[currEscapedHexPos] = currChar;

                                    currEscapedHexPos++;

                                    // End of sequence.
                                    if (currEscapedHexPos == escapedHexChars.length) {
                                        // Reset.
                                        currEscapedHexPos = -1;

                                        // Unescape.
                                        int code = Integer
                                                .parseInt(new String(escapedHexChars), 16);
                                        char unescaped = (char) code;
                                        columnContents.append(unescaped);
                                    }
                                }
                                else if (columnCount == 0 && currChar == COMMENT_PREFIX) {
                                    commentRow = true;
                                }
                                // Not part of an escape sequence.
                                else {
                                    columnContents.append(currChar);
                                }
                        }

                        prevChar = currChar;
                    }

                    if (read1RowFully) {
                        break;
                    }
                }

                // If the row was not a comment-row, break.
                if (commentRow == false) {
                    break;
                }

            }

            return read1RowFully;
        }

        private void replaceCurrentColumnWithOOBData(String oobFileRef) throws IOException {
            int x = Constants.OUT_OF_BAND_REF_PREFIX.length();
            String oobFileName = oobFileRef.substring(x, oobFileRef.length());

            File file = new File(currentFile.getParentFile(), oobFileName);

            if (file.exists() == false || file.canRead() == false) {
                throw new IOException("File: " + file + " is not available or cannot be read.");
            }

            /*
             * Part of the Escape-logic is duplicated here. Is there a better
             * way?
             */
            StringBuffer stringBuffer = new StringBuffer();
            char[] buffer = new char[2048];
            int count = 0;
            char[] escapedHexChars = new char[4];
            int currEscapedHexPos = -1;
            char currChar = 0;
            char prevChar = 0;

            BufferedReader oobReader = new BufferedReader(new InputStreamReader(
                    new FileInputStream(file), fileEncoding));
            try {
                while ((count = oobReader.read(buffer)) != -1) {
                    for (int i = 0; i < count; i++) {
                        currChar = buffer[i];

                        // Start of escape sequence.
                        if (prevChar == '\\' && currChar == 'u') {
                            // Start collecting the next few chars.
                            currEscapedHexPos = 0;
                        }
                        // Escape sequence has already started.
                        else if (currEscapedHexPos >= 0) {
                            escapedHexChars[currEscapedHexPos] = currChar;

                            currEscapedHexPos++;

                            // End of sequence.
                            if (currEscapedHexPos == escapedHexChars.length) {
                                // Reset.
                                currEscapedHexPos = -1;

                                // Unescape.
                                int code = Integer.parseInt(new String(escapedHexChars), 16);
                                char unescaped = (char) code;
                                stringBuffer.append(unescaped);
                            }
                        }
                        else {
                            stringBuffer.append(currChar);
                        }

                        prevChar = currChar;
                    }
                }
            }
            finally {
                try {
                    oobReader.close();
                }
                catch (Exception e) {
                    // Ignore warning.
                    e.printStackTrace(System.err);
                }
            }

            columnContents.delete(0, columnContents.length());
            columnContents.append(stringBuffer);
            stringBuffer.delete(0, stringBuffer.length());
        }

        private void recordAndPurgeCurrentColumn(String defaultValue) {
            int length = columnContents.length();

            String columnValue = defaultValue;

            if (length > 0) {
                columnValue = columnContents.toString();

                // Purge the column buffer.
                columnContents.delete(0, length);
            }

            stringsInRow.add(columnValue);
        }

        private void recordAndPurgeCurrentColumn() {
            recordAndPurgeCurrentColumn(null);
        }

        private void recordAndPurgeCurrentRow() {
            currentRow = (String[]) stringsInRow.toArray(new String[stringsInRow.size()]);
            stringsInRow.clear();
        }
    }

    /**
     * @param args [0]: Directory containing all CSV file fragments. [1]: File name prefix.
     * @throws Exception
     */
    public static void main(String[] args) throws Exception {
        CSVReader reader = new CSVReaderImpl(args[0], args[1]);

        PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(args[0]
                + "/Check.txt")));

        String[] columns = null;
        while ((columns = reader.nextRow()) != null) {
            for (int i = 0; i < columns.length; i++) {
                writer.print("->" + columns[i] + "<-");
                writer.print(' ');
            }

            writer.println();
            writer.println("-----------------------------------");
        }

        writer.close();
    }
}