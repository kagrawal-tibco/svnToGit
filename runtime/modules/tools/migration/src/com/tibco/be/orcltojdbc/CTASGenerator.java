package com.tibco.be.orcltojdbc;

/**
 * An alternate program for migrating from types --> jdbc.
 * Useful when source/target schemas reside on the same oracle instance
 * 
 * This utility generates "create table ... as select" or "insert into .. select" scripts for 
 * Oracle type based migration to Oracle JDBC
 * 
 * It is necessary to first create the jdbc schema by running the script generated by
 * be-jdbcdeploy. This script relies on the table names / aliases, etc 
 * as generated by be-jdbcdeploy.
 * 
 */
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;


public class CTASGenerator {
    
    static {
        com.tibco.cep.Bootstrap.ensureBootstrapped();
    }
    

	Map orclTypeToTable = new LinkedHashMap();
	
	Map orclTypeToAttrib = new LinkedHashMap();
	
	Map beTypeToOrclType = new LinkedHashMap();
	
	Map jdbcTableToAttrib = new LinkedHashMap();

	Map aliasToCol = new LinkedHashMap();
	
	Map tabAlias = new LinkedHashMap();
	
	boolean insertStmt;
	
	String srcSchema, targetSchema;
	String url, dbUser, dbPwd;
	
	public CTASGenerator (String args[]) {
		
		parseArgs(args);

	}


	public static void main(String[] args) throws Exception {
		
		CTASGenerator gen = new CTASGenerator(args);
		gen.generate();
	}
	
	
	public void generate() throws Exception {

		Connection conn = null;
		try {
			conn = makeNewConnection();
			initOrclTypeMaps(conn);
			initJdbcMaps(conn);
			generateScript();
		} finally {
			if (conn != null) {
				conn.close();
			}
		}
    }
	
	
	private void parseArgs(String[] args) {
		int i = 0;
        while(i < args.length)
        {
            if (args[i].compareTo("-url")==0)
            {
            	url = args[i+1];
                i += 2;
            }
            else if (args[i].compareTo("-user")==0)
            {
                dbUser = args[i+1];
                i += 2;
            }
            else if (args[i].compareTo("-pwd")==0)
            {
                dbPwd = args[i+1];
                i += 2;
            }
            else if (args[i].compareTo("-types")==0)
            {
            	srcSchema = args[i+1];
                i += 2;
            }            
            else if (args[i].compareTo("-jdbc")==0)
            {
            	targetSchema = args[i+1];
                i += 2;
            }
            else if (args[i].compareTo("-insert")==0)
            {
            	insertStmt = true;
                i += 1;
            }
            else if (args[i].compareTo("-create")==0)
            {
            	insertStmt = false;
                i += 1;
            }
            else
            {
            	System.err.println ("Usage: java -url <database-url> -usr <username> -pwd <password> -types <types_schema> -jdbc <jdbc_schema> -create|-insert");
            	System.exit(1);
                i++;
            }
        }
	}
	
	
	private void generateScript() {
		
		for (Iterator i = jdbcTableToAttrib.entrySet().iterator(); i.hasNext();) {
			Map.Entry e = (Entry) i.next();
			String jdbcTable = (String) e.getKey();
			JdbcAttribs jdbcAttribs = (JdbcAttribs) e.getValue();
			
			if (jdbcAttribs.fldName != null) {
				//this is a join table, so handle it elsewhere
				generateJoinTableScript (jdbcTable, jdbcAttribs);
				continue;
			}

			String orclType = (String) beTypeToOrclType.get(jdbcAttribs.beType);
			String orclTbl = (String) orclTypeToTable.get(orclType);
			OrclAttribs orclAttribs = (OrclAttribs) orclTypeToAttrib.get(orclType);
			
			String sqlStmt = null;
			if (insertStmt) {
				sqlStmt = "insert /*+ APPEND */ into ";
			} else {
				sqlStmt = "create table ";
			}
			
			StringBuilder sb = new StringBuilder(sqlStmt + jdbcTable + " (");
			
			List attribNames = new ArrayList();
			for (Iterator j = jdbcAttribs.attribs.entrySet().iterator(); j.hasNext();) {
				Map.Entry e1 = (Entry) j.next();
				String colName = (String) e1.getKey();
				String colType = (String) e1.getValue();
				sb.append(colName);
				if (j.hasNext()) {
					sb.append(", ");
				}
				String origColNm = colName;
				if (colName.endsWith ("_TM")){
					colName = colName.substring(0,colName.indexOf ("_TM"));
				} else if (colName.endsWith("_TZ")) {
					colName = colName.substring(0,colName.indexOf ("_TZ"));
				}
				//search for colName in the betypes..
				String typeColName = null;
				
				if ((typeColName = (String) orclAttribs.upperToAttrib.get(colName)) == null) {
					if (colName.equals("CACHEID")){
						attribNames.add("CACHEID");
					} else if (colName.equals("PARENT$_ID$")){
						attribNames.add("PARENT$.ID$");
					} else if (colName.equals("PAYLOAD__P")) {
						attribNames.add(orclAttribs.payloadCol);
					} else {
						//now try the alias..
						String colAliasVal = null;
						List l = null;
						if ((l = (List) aliasToCol.get(colName)) != null) {
							for (int k=0; k<l.size(); k++) {
								String colNm = (String) l.get(k);
								if (orclAttribs.attribs.containsKey(colNm)) {
									attribNames.add(colNm);
									break;
								}
							}
							//attribNames.add(colAliasVal);
						} else {
							System.err.println(jdbcTable + colName);
						}
					}
				} else {
					
					if (origColNm.endsWith("_TM")) {
						attribNames.add("\"" + typeColName+"\".TM");
					} else if (origColNm.endsWith("_TZ")) {
						attribNames.add("\"" + typeColName+"\".TZ");
					} else {
						attribNames.add(typeColName);
					}
				}
			}
			
			sb.append(")");
			if (insertStmt) {
				sb.append(" select ");
			} else {
				sb.append(" nologging as select ");
			}
			
			for (int j=0; j<attribNames.size(); j++) {
				String attribName = (String) attribNames.get(j);
				if (attribName.endsWith (".TM") || attribName.endsWith(".TZ") || attribName.equals("PARENT$.ID$")) {
					sb.append(" d.entity." + attribName);
				} else if (attribName.equals("CACHEID")){
					sb.append(" d.cacheid");
				} else {
					sb.append(" d.entity." + "\"" + attribName + "\"");
				}
				if (j < attribNames.size() - 1) {
					sb.append(", ");
				}
			}
			sb.append(" from " + srcSchema + "." + orclTbl + " d;");
			System.out.println(sb.toString());
			if (insertStmt) {
				System.out.println("commit;");
			}
		}
	}
	
    private void generateJoinTableScript (String jdbcTable, JdbcAttribs jdbcAttribs) {

    	String fieldName = jdbcAttribs.fldName;
		String orclType = (String) beTypeToOrclType.get(jdbcAttribs.beType);
		String orclTbl = (String) orclTypeToTable.get(orclType);
		OrclAttribs orclAttribs = (OrclAttribs) orclTypeToAttrib.get(orclType);
		
		String sqlStmt = null;
		if (insertStmt) {
			sqlStmt = "insert /*+ APPEND */ into ";
		} else {
			sqlStmt = "create table ";
		}
		
		StringBuilder sb = new StringBuilder(sqlStmt + jdbcTable + " (");		
		for (Iterator j = jdbcAttribs.attribs.entrySet().iterator(); j.hasNext();) {
			Map.Entry e1 = (Entry) j.next();
			String colName = (String) e1.getKey();
			String colType = (String) e1.getValue();
			sb.append(colName);
			if (j.hasNext()) {
				sb.append(", ");
			}
		}
		if (fieldName.equals("rrf$")) { //relationship is a reverse ref..
			sb.append(") ");
			if (insertStmt) {
				sb.append (" ");
			} else {
				sb.append (" nologging as ");
			}
			sb.append("select d.entity.id$, a.propertyName$, a.id$ from " + srcSchema + "." + orclTbl + " d, table (d.entity.REVERSEREFS$) a;");
		} else {
			String type = (String) orclAttribs.attribs.get(fieldName);
			if (type.contains("T_ENTITY_REF_TABLE")) {
				sb.append(") ");
				if (insertStmt) {
					sb.append (" ");
				} else {
					sb.append (" nologging as ");
				}
				sb.append("select d.entity.id$, 0, a.id$ from " + srcSchema + "." + orclTbl + " d, table (d.entity." + "\"" + fieldName + "\"" + ") a;");
			} else {
				sb.append(")");
				if (insertStmt) {
					sb.append (" ");
				} else {
					sb.append (" nologging as ");
				}
				sb.append("select d.entity.id$, 0, a.COLUMN_VALUE from " + srcSchema + "." + orclTbl + " d, table (d.entity." + "\"" + fieldName + "\"" + ") a;");
			}
		}
		System.out.println(sb.toString());
		if (insertStmt) {
			System.out.println("commit;");
		}
    }
    
	private void initJdbcMaps(Connection conn) throws SQLException {

		Statement s = conn.createStatement();
		ResultSet rs = s.executeQuery("select * from " + targetSchema + ".classtotable order by classname");
		while (rs.next()) {
			String beType = rs.getString("CLASSNAME").trim();
			String  fldName = rs.getString("FIELDNAME");
			String oracleTable = rs.getString("TABLENAME").trim();
			
			JdbcAttribs jdbcAttribs = new JdbcAttribs();
			jdbcAttribs.name = oracleTable;
			jdbcAttribs.beType = beType;
			jdbcAttribs.fldName = fldName;
			jdbcTableToAttrib.put(oracleTable, jdbcAttribs);
			Statement s1 = conn.createStatement();
			ResultSet rs1 = s1.executeQuery ("select * from all_tab_cols where owner = '" + targetSchema.toUpperCase() + "' and table_name = '" + oracleTable.toUpperCase() + "' order by column_id");
			while (rs1.next()) {
				String col = rs1.getString("COLUMN_NAME");
				String type = rs1.getString("DATA_TYPE");
				jdbcAttribs.attribs.put(col, type);
			}
			rs1.close();
		}
		rs.close();
		
		rs = s.executeQuery("select * from " + targetSchema + ".bealiases");
		while (rs.next()) {
			String beName = rs.getString("BENAME");
			String alias = rs.getString("ALIAS");
			String[] strs = beName.split("\\.");
			if (beName.startsWith("COLUMN")) {
				List l = null;
				if ((l = (List) aliasToCol.get(alias.toUpperCase())) == null) {
					l = new ArrayList();
					aliasToCol.put(alias.toUpperCase(),l);
				}
				l.add(strs[1]);
			} else if (beName.startsWith("TABLE")) {
				tabAlias.put(strs[1], alias);
			}
		}
	}

	private void initOrclTypeMaps(Connection conn) throws SQLException {
		
		Statement s = conn.createStatement();
		ResultSet rs = s.executeQuery("select * from " + srcSchema + ".classtooracletype");
		
		while (rs.next()) {
			String oracleType = rs.getString("ORACLETYPE").trim();
			String oracleTable = rs.getString("ORACLETABLE").trim();
			String beType = rs.getString("CLASSNAME").trim();
			orclTypeToTable.put(oracleType, oracleTable);
			//orclTypeBEType.put(oracleType, beType);
			beTypeToOrclType.put(beType, oracleType);
			String qry = "select * from all_type_attrs where type_name = '" + oracleType.toUpperCase() +"' and owner = '" + srcSchema.toUpperCase() + "'";
			Statement s1 = conn.createStatement();

			//System.out.println(qry);
			ResultSet rs1 = s1.executeQuery (qry);
			OrclAttribs attribs = new OrclAttribs();
			attribs.name = oracleType;
			attribs.beType = beType;
			orclTypeToAttrib.put (oracleType, attribs);
			while (rs1.next()) {
				String col = rs1.getString("ATTR_NAME");
				String type = rs1.getString("ATTR_TYPE_NAME");
				attribs.attribs.put(col, type);
				attribs.upperToAttrib.put(col.toUpperCase(), col);
				if (attribs.payloadCol == null && type.equals("BLOB")) {
					attribs.payloadCol = col;
				} else if (type.equals("BLOB")) {
					System.err.println ("Duplicate BLOB type.." + oracleType + ":" + col);
				}
			}
			rs1.close();
		}
		rs.close();
	}
    
    
    private Connection makeNewConnection() throws Exception {

		Class.forName("oracle.jdbc.OracleDriver");
		Connection connection = DriverManager.getConnection(url, dbUser, dbPwd);
		//Connection connection = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:orcl", "system", "system");

		return connection;

	}
    

    static class OrclAttribs {
    	String name;
    	String beType;
    	Map attribs = new LinkedHashMap();
    	Map upperToAttrib = new LinkedHashMap();
    	String payloadCol;
    }
    
    static class JdbcAttribs {
    	String name;
    	String beType;
    	String fldName;
    	Map attribs = new LinkedHashMap();
    }
}
