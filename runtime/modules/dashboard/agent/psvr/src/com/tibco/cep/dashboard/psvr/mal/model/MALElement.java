package com.tibco.cep.dashboard.psvr.mal.model;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import com.tibco.cep.dashboard.common.utils.StringUtil;
import com.tibco.cep.dashboard.psvr.mal.MALTransaction;
import com.tibco.cep.dashboard.psvr.mal.store.Identity;
import com.tibco.cep.dashboard.psvr.mal.store.UserIdentity;
import com.tibco.cep.dashboard.security.SecurityToken;


/**
 * <code>MALElement</code> is the base class for all the MAL elements. The MAL 
 * represents the concrete version of the Insight Configuration which is stored
 * in the MDS as a 'ontology'. 
 * 
 * @author apatil
 * 
 */
public abstract class MALElement implements PropertyChangeListener {
    
    //common properties for all elements
    private Object persistedObject;
    private String id;
    private String name;
//    private String folder;
//    private String namespace;
    private String description;
    private String definitionType;
    
    //properties for top level element
    private boolean topLevelElement;
    private Identity owner;
    private Set<MALElement> references;
    
    //properties for non top level elements
    private MALElement parent;
    private MALElement topLevelParent;
    
    //properties to track changes in the element
    private boolean dirty;
    private long lastModifiedTime;
    private HashMap<String, PropertyTracker> propertyTrackingMap;
    
    //properties for runtime-generated elements
    private boolean autoGenerated;

    /**
     * Default Constructor
     */
    public MALElement(){
    	references = new HashSet<MALElement>();
    	dirty = false;
    	lastModifiedTime = -1;
        propertyTrackingMap = new HashMap<String, PropertyTracker>();
        //by default no element is auto-generated
        autoGenerated = false;
    }
    
	public final void setPersistedObject(Object persistedCopy) {
		this.persistedObject = persistedCopy;
	}
	
	public final Object getPersistedObject() {
		return persistedObject;
	}

    /**
     * Sets the id of the element. 
     * <b>Only for internal usage</b>
     * @param id The id to set.
     */
    public final void setId(String id) {
    	if (StringUtil.isEmptyOrBlank(id) == true){
    		throw new IllegalArgumentException("id cannot be null for "+definitionType);
    	}
        this.id = id;
    }
    
    /**
     * Returns the id of the element
     * @return the id.
     */
    public final String getId() {
        return id;
    }
    
    public final void setName(String name) {
    	if (StringUtil.isEmptyOrBlank(name) == true){
    		throw new IllegalArgumentException("name cannot be null for "+definitionType);
    	}     	
        this.name = name;
    }
    
    public final String getName() {
        return name;
    }    
    
//	public void setFolder(String folder) {
//		this.folder = folder;
//	}
//
//	public String getFolder() {
//		return folder;
//	}
//	
//	public void setNamespace(String namespace) {
//		this.namespace = namespace;
//	}
//
//	public String getNamespace() {
//		return namespace;
//	}
	
	public void setDescription(String description) {
		this.description = description;
	}

	public String getDescription() {
		return description;
	}	
	
    /**
     * Sets the type of the element. The type of a element is the 'type' defined 
     * in the Insight Schema Definition. 
     * <b>Only for internal usage</b>
     * @param type The type to set.
     */
    public void setDefinitionType(String type) {
    	if (StringUtil.isEmptyOrBlank(type) == true){
    		throw new IllegalArgumentException("definition type cannot be null for "+getClass().getName());
    	}    	
        this.definitionType = type;
    }	
    
    /**
     * Returns the type of the element. The type of a element is the 'type' defined 
     * in the Insight Schema Definition.
     * @return Returns the type.
     */
    public String getDefinitionType() {
        return definitionType;
    }
    
    public final void setTopLevelElement(boolean topLevelElement) {
        this.topLevelElement = topLevelElement;
    }     
    
    public final boolean isTopLevelElement() {
        return topLevelElement;
    }
    
	public void setOwner(Identity owner){
		if (owner == null){
			throw new IllegalArgumentException("owner cannot be null");
		}
		if (topLevelElement == false){
			throw new IllegalStateException("owner cannot be set for a non top level element["+this+"]");
		}
		if (owner instanceof UserIdentity && owner.getParent() == null){
			throw new IllegalArgumentException(owner+" does not have a valid parent");
		}
		this.owner = owner;
	}
	
	public Identity getOwner(){
		if (topLevelElement == true){
			if (owner == null){
				throw new IllegalStateException(this+" is a top level element with no owner");
			}
			return owner;
		}
		if (owner == null){
			owner = getTopLevelParent().owner;
		}
		return owner;
	}	
	
	public boolean isOwnedBy(SecurityToken token){
		if (owner == null){
			getOwner();
		}
		if (owner.getId().equals(token.getUserID()) == true){
			if (owner.getParent().getId().equals(token.getPreferredPrincipal().getName()) == true){
				return true;
			}
		}
		return false;
	}	
	
	public void addReference(MALElement element){
		if (topLevelElement == false){
			throw new IllegalStateException(element+" can be added as a reference to a top level element");
		}
		references.add(element);
	}
	
	public void removeReference(MALElement element){
		if (topLevelElement == false){
			throw new IllegalStateException(element+" can be removed as a reference from a top level element");
		}
		references.remove(element);
	}
	
	public Collection<MALElement> getReferences(){
		return new ArrayList<MALElement>(references);
	}
	
	public final void setParent(MALElement parent) {
		if (topLevelElement == true){
			throw new IllegalStateException("parent cannot be set for "+this);
		}		
		this.parent = parent;
	}	
	
	public final MALElement getParent() {
		return parent;
	}

	public MALElement getTopLevelParent(){
//		if (topLevelElement == true){
//			return this;
//		}
//		if (topLevelParent == null){
//			topLevelParent = parent;
//			while (topLevelParent != null && topLevelParent.isTopLevelElement() == false) {
//				topLevelParent = topLevelParent.getParent();
//			}
//			if (topLevelParent == null) {
//				throw new IllegalStateException(this + " does not have a valid parent");
//			}			
//		}
//		return topLevelParent;
		if (topLevelParent == null){
			List<MALElement> parentage = getParentage();
			if (parentage.get(0).isTopLevelElement() == false){
				throw new IllegalStateException(this + " does not have a valid parent");
			}
			topLevelParent = parentage.get(0);
		}
		return topLevelParent;
	}
	
	public List<MALElement> getParentage() {
		List<MALElement> parentage = new LinkedList<MALElement>();
		parentage.add(this);
		if (this.isTopLevelElement() == true) {
			return parentage;
		} 
		MALElement currParent = parent;
		while (currParent != null && currParent.isTopLevelElement() == false) {
			parentage.add(currParent);
			currParent = currParent.getParent();
		}
		if (currParent != null){
			parentage.add(currParent);
		}
		Collections.reverse(parentage);
		return parentage;
	}	
	
	public final boolean isAutoGenerated() {
		return autoGenerated;
	}

	public final void setAutoGenerated(boolean autoGenerated) {
		this.autoGenerated = autoGenerated;
	}	
	
    public abstract void addPropertyChangeListener(PropertyChangeListener listener);
    
    public abstract boolean removePropertyChangeListener(PropertyChangeListener listener);
	
    public void propertyChange(PropertyChangeEvent evt) {
        Object eventSrc = evt.getSource();
        if (eventSrc == this){
        	MALTransaction transaction = MALTransaction.getCurrentTransaction();
        	if (transaction == null){
        		throw new IllegalStateException("Changing of "+definitionType+" outside of a transaction is not permitted");
        	}
	        String propertyModified = evt.getPropertyName();
	        Object oldValue = evt.getOldValue();
	        Object newValue = evt.getNewValue();
	        if (propertyModified.startsWith("_") == true){
	            propertyModified = propertyModified.substring(1);
	        }
	        if (newValue instanceof List){
	            //INFO hardcoding the ending of list variables with 'List'
	            int idx = propertyModified.indexOf("List");
	            if (idx != -1){
	                propertyModified = propertyModified.substring(0,idx);
	            }
	        }
	        PropertyTracker tracker = propertyTrackingMap.get(propertyModified);
	        if (tracker == null){
	            tracker = new PropertyTracker(propertyModified,oldValue,newValue);
	            propertyTrackingMap.put(propertyModified,tracker);
	        }
	        else{
	            tracker.newValue = newValue;
	        }
	        setDirty(true);
	        //record the element change
	        transaction.recordChange(this, propertyModified, oldValue, newValue);
        }
    }
    
    /**
     * Listens for property change events from its children.
     * If the property change is from one of its child, then a 
     * <code>PropertyTracker</code> is created and stored against the
     * property being modified
     * @param evt The <code>PropertyChangeEvent</code> which contains all the information
     */

    private void setDirty(boolean b) {
        if (dirty == false && b == true){
            dirty = b;
            lastModifiedTime = System.currentTimeMillis();
            if (parent != null) {
            	parent.setDirty(b);
            }
        }
	}    
    	
    /**
     * Returns <code>true</code> if the element has changed else <code>false</code>
     * An element is considered changed if its properties change.
     * @return Returns the dirty.
     */
    public final boolean isDirty() {
        return dirty;
    }
    
    public final long getLastModifiedTime(){
    	return lastModifiedTime;
    }
    
	/**
     * Returns the <code>iterator</code> which gives the names of the properties
     * which have been modified
     * @return A <code>iterator</code> over the modified property names
     */
    public Iterator<String> getModifiedPropertyNames(){
        return propertyTrackingMap.keySet().iterator();
    }
    
    /**
     * Checks whether a property is modified.
     * @param propertyName the property to check
     * @return <code>true</code> if the given property is modified, 
     * or <code>false</code> otherwise
     */
    public boolean isPropertyModified(String propertyName) {
        return propertyTrackingMap.containsKey(propertyName);
    }
    
    /**
     * Returns the instance of the <code>PropertyTracker</code> which is tracking
     * the changes of the specified property. 
     * @param propertyName The property whose changes are needed
     * @return An instance of <code>PropertyTracker</code> if found else <code>null</code>
     */
    public PropertyTracker getPropertyTracker(String propertyName){
        return propertyTrackingMap.get(propertyName);
    }
    
    /**
     * Resets the property tracking system. Should be called after the current 
     * changes have been either commited or rolled back.
     */
    public void resetPropertyTracking(){
        propertyTrackingMap.clear();
        dirty = false;
    }
    
    public final void copyPropertyTrackingInfo(MALElement element){
        if (element == null){
            throw new IllegalArgumentException("Cannot copy property tracking information to a null object");
        }
        if (element.definitionType == null){
            throw new IllegalArgumentException("Definition type is not set on "+element);
        }
        if (element.definitionType.equals(this.definitionType) == false){
            throw new IllegalArgumentException("Definition type do not match ["+element.definitionType+" != "+this.definitionType+"]");
        }
        element.dirty = this.dirty;
        element.propertyTrackingMap = new HashMap<String, PropertyTracker>(this.propertyTrackingMap);
    }
    
    public String toString(){
        return "MAL"+definitionType+"[id="+id+",name="+name+",owner="+owner+",hashcode="+hashCode()+"]";    
    }
    
    @Override
    public int hashCode() {
    	return id.hashCode();
    }

    @Override
    public boolean equals(Object obj) {
    	if (obj == this){
    		return true;
    	}
    	if (obj.getClass().equals(getClass()) == false){
    		return false;
    	}
    	MALElement element = (MALElement) obj;
    	return element.id.equals(id);
    }


}