/**
 * @description Save local changes made on the client side to workspace.
 */
WebStudio.Core.Concepts.DataSources.WS_C_TemporaryReturnData rulefunction WebStudio.Core.RuleFunctions.Actions.WS_RF_SaveLocalChangesToWorkspace {
	attribute {
		validity = ACTION;
	}
	scope {
		Object servletRequest;
		WebStudio.Security.Authn.Concepts.WS_C_LoggedInUser loggedInUser;
		String contentType;
	}
	body {
		//Either existing version for artifact will be updated or a new one created.
		Object LOGGER = Log.getLogger("WebStudio.Core.RuleFunctions.Actions.WS_RF_SaveLocalChangesToWorkspace");
		
		String responseMessage = "Save successfully completed";
		String errorCode = null;
		int responseStatus = 0;
		int recordCount = 1;
		
		WS_C_ResponseData responseData = null;
		if (!WS_RF_CheckHTTPMethod(servletRequest, "POST")) {
			responseStatus = -1;
			recordCount = 0;
			errorCode = "ERR_5101";
			responseMessage = "Invalid HTTP Method, expect method is [POST].";
		} else {
			String username = loggedInUser.username;
			String[] roles = Instance.PropertyArray.toArrayString(loggedInUser.roles);
			
			Object requestDataBytes = HTTP.Servlet.Request.getRequestContent(servletRequest);
			String requestData = String.convertByteArrayToString(requestDataBytes, "UTF-8");
			Log.log(LOGGER, "Debug", "Raw Save request data - %s", requestData);
			
			String scsIntegrationType = System.getSystemPropertyAsString("ws.scs.impl.type", null);
			
			responseData = 
				Instance.newTransientInstance("/WebStudio/Core/Concepts/DataSources/WS_C_ResponseData");
			//Create a concept out of it
			//Convert to concept model
			WS_C_SaveRequest saveRequest = null;
			if (String.equals(contentType, System.getGlobalVariableAsString("WebStudio/CONTENT_TYPE/XML", "application/xml"))) {
				saveRequest = Instance.createTransientInstanceFromXML("/WebStudio/Core/Concepts/Request/Usecases/Save/WS_C_SaveRequest", requestData);
			} else {
				saveRequest = Instance.createTransientInstanceFromJSON("/WebStudio/Core/Concepts/Request/Usecases/Save/WS_C_SaveRequest", requestData);
			}
			WS_C_SaveRequestProject[] saveProjects = 
				Instance.PropertyArray.toArrayContainedConcept(saveRequest.data.project);	
			
			Log.log(LOGGER, "Info", "Number of projects affected for save operation %s", saveProjects@length);
			
			String subscriptionId = null;
			if (loggedInUser.jwtToken != null) subscriptionId = loggedInUser.jwtToken.sbsc;
						
			//Lock and load workspace concept
			String userWorkspaceExtId = WS_RF_CreateUserArtifactExtId("WORKSPACE", null, null, username, null, null);
			boolean userWorkspaceLock = Cluster.DataGrid.Lock(userWorkspaceExtId, 1000, false);
			
			String scsRootURL = null; 
			if (userWorkspaceLock) {
				WS_C_UserWorkspace userWorkspace = Instance.getByExtIdByUri(userWorkspaceExtId, "/WebStudio/Core/Concepts/WS_C_UserWorkspace");
				if (userWorkspace == null) {
					Log.log(LOGGER, "Warn", "Workspace does not exist for user %s. Please perform checkout first.", username);
					responseMessage = String.format("Workspace not found for user %s. Please perform checkout first.", username);
					errorCode = "ERR_1005";
					recordCount = 0;
					responseStatus = -1;
				} else {
					for (int loop = 0; loop < saveProjects@length; loop++) {
						WS_C_SaveRequestProject requestSaveProject = saveProjects[loop];
						String projectName = requestSaveProject.name;
						//Look for cached user project
						String projectExtId = WS_RF_CreateUserArtifactExtId(null, null, projectName, loggedInUser.username, null, null);
						WS_C_UserProject userProject = Instance.getByExtIdByUri(projectExtId, "/WebStudio/Core/Concepts/WS_C_UserProject");
						if (userProject == null) {
							Log.log(LOGGER, "Warn", "Project does not exist for user %s in workspace. Please perform checkout first.", username);
							responseMessage = String.format("Project with name %s not found for user %s.Please perform checkout first.", projectName, username);
							errorCode = "ERR_1011";
							recordCount = 0;
							responseStatus = -1;
						} else {
							Log.log(LOGGER, "Debug", "User project instance id %s", userProject@id);
							Log.log(LOGGER, "Debug", "Total Artifacts in the project - %s", userProject.userArtifacts@length);
							
							scsRootURL = WS_RF_GetSCSRootURL(projectName, subscriptionId);
							if (scsRootURL == null) {
								throw Exception.newException(null, "Source control repository location not present. Set ws.scs.rootURL property", null);
							}
							//Get all artifact items in it
							WS_C_ArtifactSaveDataItem[] artifactSaveableItems = Instance.PropertyArray.toArrayContainedConcept(requestSaveProject.artifactItem);
							Log.log(LOGGER, "Debug", "Number of items affected for project %s for save operation %s", projectName, artifactSaveableItems@length);
						
							for (int innerLoop = 0; innerLoop < artifactSaveableItems@length; innerLoop++) {
								WS_C_ArtifactSaveDataItem artifactSaveableItem = artifactSaveableItems[innerLoop];
								String artifactPath = artifactSaveableItem.artifactPath;
								String artifactType = artifactSaveableItem.artifactType;
								String implementsPath = artifactSaveableItem.implementsPath;
								String artifactContent = artifactSaveableItem.artifactContent;
								
								//Get its content
								Log.log(LOGGER, "Debug", "Artifact Path - [%s], Type - [%s], ImplementsPath - [%s], RulePriority - [%s], Description - [%s]", artifactPath, artifactType, implementsPath, artifactSaveableItem.rulePriority, artifactSaveableItem.description);
								Log.log(LOGGER, "Debug", "Artifact Content %s", artifactContent);
								
								WS_C_CheckArtifactLockResponse artifactLockStatus 
													= WebStudio.Core.RuleFunctions.Actions.Lifecycle.Lock.WS_RF_CheckMasterArtifactLock(projectName, artifactPath, loggedInUser.username);
								if (artifactLockStatus.holdsLock || artifactLockStatus.lockOwner == null) {
																	
									//Look for concept with this extid	
									String userArtifactExtId = WS_RF_CreateUserArtifactExtId(null, artifactPath, projectName, username, null, null);																
									boolean userArtifactLock = Cluster.DataGrid.Lock(userArtifactExtId, 1000, false);
									if (userArtifactLock) {
										//Fetch from cache.
										WS_C_UserArtifact userArtifactConceptInstance = null;
										if (artifactType == "ruletemplateinstance" || artifactType == "ruletemplate") {
											userArtifactConceptInstance = Cluster.DataGrid.CacheLoadConceptByExtIdByUri(userArtifactExtId, false, "/WebStudio/Core/Concepts/RuleTemplateInstance/WS_C_RuleTemplateInstanceUserArtifact");
										} else if (artifactType == "rulefunctionimpl") {
											userArtifactConceptInstance = Cluster.DataGrid.CacheLoadConceptByExtIdByUri(userArtifactExtId, false, "/WebStudio/Core/Concepts/Decision/WS_C_UserDTableArtifact");
										} else if (artifactType == "beprocess") {
											userArtifactConceptInstance = Cluster.DataGrid.CacheLoadConceptByExtIdByUri(userArtifactExtId, false, "/WebStudio/Core/Concepts/Process/WS_C_ProcessUserArtifact");
										} else if (artifactType == "domain") {
											userArtifactConceptInstance = Cluster.DataGrid.CacheLoadConceptByExtIdByUri(userArtifactExtId, false, "/WebStudio/Core/Concepts/Domain/WS_C_DomainUserArtifact");
										}
										
										if (userArtifactConceptInstance != null) {
											Log.log(LOGGER, "Debug", "RTI [%s], Id [%s], UUID [%s] & ExtId [%s]", userArtifactConceptInstance.artifactPath, userArtifactConceptInstance@id, userArtifactConceptInstance.UUID, userArtifactConceptInstance@extId);
										}
										
										boolean allowSave = true;
										boolean newArtifact = false;
										if (userArtifactConceptInstance == null) {
											//New Addition
											Log.log(LOGGER, "Debug", "No artifact found for artifact path [%s]. Need to create new.", artifactPath);
											//Check if any master exists for same artifact and if yes do not allow this creation.
											//Takes care of corner case when a user tries to create a new artifact with same name
											//at same path when a master copy already exists for it. That can cause further inconsistencies
											//hence should be avoided.											
											String masterArtifactExtId = WS_RF_CreateUserArtifactExtId(null, artifactPath, projectName, null, subscriptionId, null);
											WS_C_MasterArtifact masterArtifact = Instance.getByExtIdByUri(masterArtifactExtId, "/WebStudio/Core/Concepts/Lifecycle/WS_C_MasterArtifact");
											
											if (masterArtifact != null) {
												//Get its current revision
												WS_C_UserArtifactRevision currentMasterRevision = Instance.PropertyAtom.getConceptReference(masterArtifact.currentMasterRevision, 1L);
												if (currentMasterRevision != null) {
													//Do not allow create
													responseMessage = String.format("Potential inconsistency situation. Master copy for Artifact [%s] already exists on server. Please update local directory or create in a different directory", artifactPath);
													errorCode = "ERR_1180";
													recordCount = 0;
													responseStatus = -1;
													allowSave = false;
												}
											}
											
											if (allowSave) {
												newArtifact = true;
												userArtifactConceptInstance = WS_RF_UserArtifactCreationFactory(userArtifactExtId, artifactPath, artifactType, artifactType, userProject@extId);
												
												if (String.equals(artifactType, "rulefunctionimpl") || String.equals(artifactType, "ruletemplateinstance")) {
													// get the base Artifact Name
													String baseArtifactName = implementsPath;
													String baseArtifactExtn = "rulefunction";
													if (String.equals(artifactType, "ruletemplateinstance")) {
														baseArtifactExtn = "ruletemplate";
													}
													userArtifactConceptInstance.baseArtifactPath = baseArtifactName + "." + baseArtifactExtn;
												}
											}						
										} else {
											if (userArtifactConceptInstance.softDelete) {
												WS_C_UserArtifactRevision checkpointRevision = Instance.PropertyAtom.getConceptReference(userArtifactConceptInstance.checkpointRevision, 1L);
												WS_C_LifecycleMetadata checkpointRevisionMetadata = null;
												if (checkpointRevision != null) {
													checkpointRevisionMetadata = Instance.PropertyAtom.getContainedConcept(checkpointRevision.lifecycleMetadata, 1L);
												}
												WS_C_ArtifactBaseState checkpointState = null;
												if (checkpointRevisionMetadata != null) {	
													checkpointState = Instance.PropertyAtom.getConceptReference(checkpointRevisionMetadata.currentState, 1L);
												}
												//If its a case of Delete and pending review, dont allow to Save (re-create/Import).												
												if (!(checkpointState instanceof WS_C_ArtifactApprovedState) && !(checkpointState instanceof WS_C_ArtifactRejectedState)) {
													Log.log(LOGGER, "Warn", "Artifact %s has been marked for deletion.", artifactPath);
													responseMessage = String.format("Artifact %s has been marked for deletion.", artifactPath);
													errorCode = "ERR_1055";
													recordCount = 0;
													responseStatus = -1;
													allowSave = false;
												}														
											}											
										}
										
										
						    			
										if (allowSave) {
							    				Concept artifactModelInstance = WS_RF_ArtifactConceptModelCreationFactory(username, roles, projectName, artifactContent, artifactType, implementsPath, userArtifactConceptInstance, contentType, artifactSaveableItem.rulePriority, artifactSaveableItem.description);
							    				
							    				if (artifactModelInstance != null) {
													Log.log(LOGGER, "Debug", "Entity [%s], Id [%s], UUID [%s] & ExtId [%s]", userArtifactConceptInstance.artifactPath, userArtifactConceptInstance@id, userArtifactConceptInstance.UUID, userArtifactConceptInstance@extId);
													//Create EModel
													Object artifactEModel = WS_RF_CreateEMFObjectForArtifact(artifactModelInstance, userArtifactConceptInstance, loggedInUser.username);
													
													//Assert it now
													WS.Common.assertInstance(artifactModelInstance, false);
													
													//Save it if property ws.scs.save.local = true
													boolean saveLocalChangesToSCS = System.getSystemPropertyAsBoolean("ws.scs.save.local", false);
													if (saveLocalChangesToSCS) {	
														WebStudio.Core.
															RuleFunctions.Utils.
																WS_RF_SaveArtifactContentsToSCS(scsIntegrationType, scsRootURL, projectName, artifactPath, artifactType, artifactEModel, "Manual via Code", 0);
														if (!String.equals(scsIntegrationType, "file")) {
															// fetch the preferences for SCS userName/password details
															String[] scsCredentials = WS_RF_GetSCSCredentials(username);
				
															WS.SCS.flushContentsToSCS(scsIntegrationType, scsRootURL, 0, scsCredentials[0], scsCredentials[1]);
														}
													}
							
					    							String operation = "Save";
												if (artifactSaveableItem.isSyncMerge) {
													operation = "Synchronize";
												}
												
												WS_E_RuleTemplateModelInstanceCreationEvent ruleTemplateModelInstanceCreationEvent =
													Event.createEvent("xslt://{{/WebStudio/Core/Events/WS_E_RuleTemplateModelInstanceCreationEvent}}<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<xsl:stylesheet xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" version=\"2.0\" exclude-result-prefixes=\"xsl xsd\"><xsl:output method=\"xml\"/><xsl:param name=\"projectName\"/><xsl:param name=\"artifactPath\"/><xsl:param name=\"artifactModelInstance\"/><xsl:param name=\"username\"/><xsl:param name=\"operation\"/><xsl:param name=\"artifactType\"/><xsl:param name=\"newArtifact\"/><xsl:template name=\"Function\" match=\"/\"><createEvent><event><projectName><xsl:value-of select=\"$projectName\"/></projectName><artifactPath><xsl:value-of select=\"$artifactPath\"/></artifactPath><xsl:if test=\"$artifactModelInstance/@extId\"><artifactModelInstanceId><xsl:value-of select=\"$artifactModelInstance/@extId\"/></artifactModelInstanceId></xsl:if><username><xsl:value-of select=\"$username\"/></username><operation><xsl:value-of select=\"$operation\"/></operation><artifactType><xsl:value-of select=\"$artifactType\"/></artifactType><isNewArtifact><xsl:value-of select=\"$newArtifact\"/></isNewArtifact></event></createEvent></xsl:template></xsl:stylesheet>");
												Event.assertEvent(ruleTemplateModelInstanceCreationEvent);
												
												String opType = "Modify";
												if (newArtifact) opType = "Create";
												if (String.equals(operation, "Synchronize")){
													WS_RF_AddAuditTrailEntry(loggedInUser.username, projectName, artifactPath, artifactType, "SYNC", "Synchronization Successful");
												} else{
													WS_RF_AddAuditTrailEntry(loggedInUser.username, projectName, artifactPath, artifactType, String.toUpperCase(opType), opType + " Successful");
												} 
												
											}
										}											
									}
								} else {
									responseStatus = -1;
									errorCode = "ERR_1145";
									responseMessage = String.format("Unable to save %s, as it has been locked by user %s", artifactPath, artifactLockStatus.lockOwner);
									Log.log(LOGGER, "Debug", responseMessage);
								}	
							}
						}	
					}	
				} 
			}
		}
			
		return WS_RF_CreateTemporaryReturnData(responseStatus, recordCount, errorCode, responseMessage, responseData);
	}
}