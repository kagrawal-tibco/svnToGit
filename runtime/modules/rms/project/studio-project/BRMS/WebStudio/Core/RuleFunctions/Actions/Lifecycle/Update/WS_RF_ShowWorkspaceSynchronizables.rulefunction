/**
 * @description Perform update on workspace bringing in new artifacts if any.
 */
WebStudio.Core.Concepts.DataSources.WS_C_TemporaryReturnData rulefunction WebStudio.Core.RuleFunctions.Actions.Lifecycle.Update.WS_RF_ShowWorkspaceSynchronizables {
	attribute {
		validity = ACTION;
	}
	scope {
		Object servletRequest;
		WebStudio.Security.Authn.Concepts.WS_C_LoggedInUser loggedInUser;
		String contentType;
	}
	body {
		Object LOGGER = Log.getLogger("WebStudio.Core.RuleFunctions.Actions.Lifecycle.Update.WS_RF_ShowWorkspaceSynchronizables");
		
		String responseMessage = null;
		String errorCode = null;
		int recordCount = 0;
		int responseStatus = 0;
		
		String scsIntegrationType = System.getSystemPropertyAsString("ws.scs.impl.type", null);
		//Check if a filter class is specified
		//TODO document this property.
		String filterClass = System.getSystemPropertyAsString("ws.scs.fetch.artifacts.filter", null);
				
		WS_C_ResponseData responseData = 
			Instance.newTransientInstance("/WebStudio/Core/Concepts/DataSources/WS_C_ResponseData");
		
		if (!WS_RF_CheckHTTPMethod(servletRequest, "POST")) {
			responseStatus = -1;
			recordCount = 0;
			errorCode = "ERR_5101";
			responseMessage = "Invalid HTTP Method, expect method is [POST].";
		} else {
			String username = loggedInUser.username;
			String[] roles = Instance.PropertyArray.toArrayString(loggedInUser.roles);
			
			String requestPostParam = System.getGlobalVariableAsString("WebStudio/requestPostParameter", "data");
			String requestData = HTTP.Servlet.Request.getRequestParameter(servletRequest, requestPostParam);
			Log.log(LOGGER, "Debug", "Request Post Data Received %s", requestData);
			if (requestData == null) {
				Object requestDataBytes = HTTP.Servlet.Request.getRequestContent(servletRequest);
				requestData = String.convertByteArrayToString(requestDataBytes, "UTF-8");
				requestData = WS.Common.cleanupRequestData(requestData);
				Log.log(LOGGER, "Debug", "Request Post Data Received %s", requestData);
			}
			
			//Convert to concept model
			WS_C_CheckoutRequest checkoutRequest = null;
			if (String.equals(contentType, System.getGlobalVariableAsString("WebStudio/CONTENT_TYPE/XML", "application/xml"))) {
				checkoutRequest = Instance.createTransientInstanceFromXML("/WebStudio/Core/Concepts/Request/Usecases/Checkout/WS_C_CheckoutRequest", requestData);
			} else {
				checkoutRequest = Instance.createTransientInstanceFromJSON("/WebStudio/Core/Concepts/Request/Usecases/Checkout/WS_C_CheckoutRequest", requestData);
			}
			
			WS_C_CheckoutRequestData requestContainedData = checkoutRequest.data;
			WS_C_CheckoutRequestProject project = Instance.PropertyArray.toArrayContainedConcept(requestContainedData.project)[0];
			String projectName = project.name;
			Log.log(LOGGER, "Debug", "Project Name Request value Received [%s]", projectName);
			
			String subscriptionId = null;
			if (loggedInUser.jwtToken != null) subscriptionId = loggedInUser.jwtToken.sbsc;
			
			String scsRootURL = WS_RF_GetSCSRootURL(projectName, subscriptionId);
			if (scsRootURL == null) {
				throw Exception.newException(null, "Source control repository location not present. Set ws.scs.rootURL property", null);
			}
			
			WS_C_ArtifactCheckoutDataItem[] artifactItems = Instance.PropertyArray.toArrayContainedConcept(project.artifactItem);
			//If this is empty assume it is entire project sync case.
			if (artifactItems@length == 0) {
				Log.log(LOGGER, "Info", "No artifacts found for synchronization for project [%s]. Defaulting to entire project synchronization.", projectName);
				WS_C_ArtifactCheckoutDataItem artifactItem = 
					Instance.newTransientInstance("/WebStudio/Core/Concepts/Request/Usecases/Checkout/WS_C_ArtifactCheckoutDataItem");
				artifactItem.artifactPath = "/";
				artifactItems = WS_C_ArtifactCheckoutDataItem[]{artifactItem};
			}
			int numberOfArtifacts = artifactItems@length;
			Log.log(LOGGER, "Debug", "Number of artifacts %s", numberOfArtifacts);
			
			String projectExtId = WS_RF_CreateUserArtifactExtId(null, null, projectName, username, null, null);
			WS_C_UserProject userProject = Instance.getByExtIdByUri(projectExtId, "/WebStudio/Core/Concepts/WS_C_UserProject");
			if (userProject == null) {
				errorCode = "ERR_1110";
				responseMessage = String.format("No project found with name [%s]", projectName); 
			} else {
				//Workspace query
				//Find artifacts in WS project matching sync path.
				String workspaceQueryString = WS_RF_BuildBasicWorkspaceQueryString();
				
				String queryArgsKey = "Query_Args_" + System.nanoTime();
				Util.HashMap.createMap(queryArgsKey);
				Util.HashMap.putObject(queryArgsKey, "parentProjectId", userProject@extId);
				
				// fetch the preferences for SCS userName/password details
				String[] scsCredentials = WS_RF_GetSCSCredentials(username);
				
				for (int loop = 0; loop < numberOfArtifacts; loop++) {
					WS_C_ArtifactCheckoutDataItem artifactDataItem = artifactItems[loop];
					String syncPath = artifactDataItem.artifactPath;
					Log.log(LOGGER, "Debug", "Synchronization Path requested [%s]", syncPath);
					//This path could be entire project specified by /, or a specific folder like /Concepts, or an artifact itself.
					Util.HashMap.putObject(queryArgsKey, "syncPath", syncPath);
					
					//Execute workspace query
					Object workspaceResultList = WS.Common.Query.executeQuery("WS-Enquiry", workspaceQueryString, Util.HashMap.getMap(queryArgsKey), true);
					Object[] workspaceResults = WS.Common.Query.listToArray(workspaceResultList);
				    Log.log(LOGGER, "Debug", "Total items in workspaceResults - %s", workspaceResults@length);
				    
				    Util.HashMap.clear(queryArgsKey);
				    Util.HashMap.deleteMap(queryArgsKey);
					
					//Execute thrash can query
					WS_C_ThrashedArtifact[] thrashedArtifacts = WS_RF_GetArtifactsFromThrashCan(projectName, syncPath, subscriptionId);
					WS_C_AbstractDataSourceRecord[] syncThrashDataSourceRecords = WS_RF_AddSyncThrashableArtifactRecord(workspaceResults, thrashedArtifacts);
					Log.log(LOGGER, "Debug", "Total items to sync from thrash - %s", syncThrashDataSourceRecords@length);
					
					if (syncThrashDataSourceRecords != null && syncThrashDataSourceRecords@length > 0) {
						for (int j = 0; j < syncThrashDataSourceRecords@length; j++) {
							recordCount++;
							Instance.PropertyArray.appendContainedConcept(responseData.record, syncThrashDataSourceRecords[j], 1L);
						}
					}
					
					if (artifactDataItem.artifactType != null && !String.equals(artifactDataItem.artifactType, "")) {
						syncPath += ("." + artifactDataItem.artifactType);
					}
					String output = WS.SCS.listManagedProjectArtifacts(scsIntegrationType, scsRootURL, projectName, syncPath, scsCredentials[0], scsCredentials[1], filterClass, null);
					Log.log(LOGGER, "Debug", "XML output %s", output);
					
					// fetch the list of supported artifact types
					WS_C_SupportedArtifactTypesConfig supportedArtifactsConfig = Cluster.DataGrid.CacheLoadConceptByExtIdByUri("WS_SUPP_ARTIFACTS_CFG", false, "/WebStudio/Core/Concepts/WS_C_SupportedArtifactTypesConfig");
					String[] artifactTypesSupported = Instance.PropertyArray.toArrayString(supportedArtifactsConfig.artifactTypes);
					
					String artifactType, artifactPath, artifactFileExtn, artifactImageSrc, EXTENSION;
					boolean isSupported, hasAccess;
			
					// make sure output is not empty
					if (output != null && !String.equals(output, "")) {
						//Convert to concept model
						WS_C_SCSProjectContents scsProjectContents = Instance.createTransientInstanceFromXML("/WebStudio/Core/Concepts/Common/WS_C_SCSProjectContents", output);
						WS_C_ProjectArtifacts projectArtifacts = scsProjectContents.projectArtifacts;
						WS_C_Artifact[] artifacts = Instance.PropertyArray.toArrayContainedConcept(projectArtifacts.artifact);
						Log.log(LOGGER, "Debug", "Project Artifact Size - %s", artifacts@length);
						
						WS_C_AbstractDataSourceRecord syncNameDataSourceRecord = null;
						for (int i = 0; i < artifacts@length; i++) {
							artifactType = artifacts[i].artifactType;
						    	artifactPath = artifacts[i].artifactPath;
						    	artifactFileExtn = artifactType;
							artifactImageSrc = Util.HashMap.get("ARTIFACT_TYPE_IMAGES", artifactType);
							if (artifactImageSrc == null) artifactImageSrc = "file.png";
							
							EXTENSION = String.toUpperCase(artifactFileExtn);
							
							Log.log(LOGGER, "Debug", "[Artifact Path] - %s, [Artifact Type] - %s, [Artifact Extension] - %s", artifactPath, artifactType, artifactFileExtn);
							
							isSupported = WS_RF_IsArtifactTypeSupported(EXTENSION, artifactTypesSupported);				
							if (isSupported) {
								hasAccess = RMS.Authorization.ensureAccess(projectName, subscriptionId, roles, artifactPath, EXTENSION, "read");
								if (hasAccess) {			
									//Check for each artifact in workspace 
									syncNameDataSourceRecord = WS_RF_AddSyncArtifactRecord(workspaceResults, projectName, artifactPath, artifactType, artifactFileExtn, username);
									if (syncNameDataSourceRecord != null) {
										recordCount++;
										Instance.PropertyArray.appendContainedConcept(responseData.record, syncNameDataSourceRecord, 1L);
									}
								}
							}
						}
					}
				}
			}
		}

		return WS_RF_CreateTemporaryReturnData(responseStatus, recordCount, errorCode, responseMessage, responseData);
	}
}