// (c) Copyright 2001,2002 TIBCO Software Inc.  All rights reserved.
// LEGAL NOTICE:  This source code is provided to specific authorized end
// users pursuant to a separate license agreement.  You MAY NOT use this
// source code if you do not have a separate license from TIBCO Software
// Inc.  Except as expressly set forth in such license agreement, this
// source code, or any portion thereof, may not be used, modified,
// reproduced, transmitted, or distributed in any form or by any means,
// electronic or mechanical, without written permission from  TIBCO
// Software Inc.

package com.tibco.hawk.jshma.plugin;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;

import COM.TIBCO.hawk.utilities.misc.ObjChecker;
import COM.TIBCO.hawk.utilities.trace.Trace;

import com.tibco.hawk.jshma.util.ContextControl;

/**
 * A convenient class to execute a system command and optionally retrieve the
 * starndard output or standard error generated by the command execution.
 */

public class CmdBase {
	String mCmd = null;
	Process mProc = null;
	BufferedReader mIn = null;
	BufferedReader mErr = null;
	Trace mTrace = null;

	CmdBase() {
	}

	/**
	 * Instantiate the command execution
	 * 
	 * @param cmd
	 *            the system command to be executed
	 */
	public CmdBase(String cmd) throws IOException {
		init(cmd, null, null);
	}

	/**
	 * Instantiate the command execution
	 * 
	 * @param cmd
	 *            the system command to be executed
	 * @param dir
	 *            the working directory of the subprocess, or null if the
	 *            subprocess should inherit the working directory of the current
	 *            process
	 */
	public CmdBase(String cmd, String dir) throws IOException {
		init(cmd, null, dir);
	}

	/**
	 * Instantiate the command execution
	 * 
	 * @param cmdarray
	 *            the system command array to be executed
	 */
	public CmdBase(String[] cmdarray) throws IOException {
		init(null, cmdarray, null);
	}

	/**
	 * Instantiate the command execution
	 * 
	 * @param cmdarray
	 *            the system command array to be executed
	 * @param dir
	 *            the working directory of the subprocess, or null if the
	 *            subprocess should inherit the working directory of the current
	 *            process
	 */
	public CmdBase(String[] cmdarray, String dir) throws IOException {
		init(null, cmdarray, dir);
	}

	void init(String cmd, String[] cmdarray, String dir) throws IOException {
		mTrace = ContextControl.getTrace();
		if (cmd != null) {
			this.mCmd = cmd;
			mTrace.log(Trace.DEBUG, "Executing Cmd: " + mCmd);
			if (dir != null)
				mProc = Runtime.getRuntime().exec(mCmd, null, new File(dir));
			else
				mProc = Runtime.getRuntime().exec(mCmd);
			mTrace.log(Trace.DEBUG, "Cmd executed");
		} else {
			mTrace.log(Trace.DEBUG, "Executing Cmd: " + ObjChecker.toString(cmdarray));
			if (dir != null)
				mProc = Runtime.getRuntime().exec(cmdarray, null, new File(dir));
			else
				mProc = Runtime.getRuntime().exec(cmdarray);
			mTrace.log(Trace.DEBUG, "Cmd executed");
		}

	}

	/**
	 * Returns the exit value for the subprocess of the executed command.
	 * 
	 * @return the exit value of the subprocess for the executed command. By
	 *         convention, the value 0 indicates normal termination.
	 * @throws IllegalThreadStateException
	 *             if the subprocess represented by this Process object has not
	 *             yet terminated.
	 * 
	 */
	public int getExitValue() throws IllegalThreadStateException {
		return mProc.exitValue();
	}

	/**
	 * Check whether there's any output stream ready in the standard output
	 */
	public boolean isOutputStreamReady() throws IOException {
		if (mIn == null)
			mIn = new BufferedReader(new InputStreamReader(mProc.getInputStream()));
		return mIn.ready();
	}

	/**
	 * Get a line from the standard output.
	 * 
	 * @return If there's nothing in the standard output, this call will be
	 *         blocked. When the command execution is completed and all standard
	 *         output have been read, this call will return null.
	 */
	public String getOutputLine() throws IOException {
		if (mIn == null)
			mIn = new BufferedReader(new InputStreamReader(mProc.getInputStream()));
		mTrace.log(Trace.DEBUG, "Before output readline");
		String line = mIn.readLine();
		mTrace.log(Trace.DEBUG, "After output readline");
		if (line == null)
			mIn.close();
		return line;
	}

	/**
	 * Check whether there's any error stream ready in the standard error
	 */
	public boolean isErrorStreamReady() throws IOException {
		if (mErr == null)
			mErr = new BufferedReader(new InputStreamReader(mProc.getErrorStream()));
		return mErr.ready();
	}

	public BufferedReader getInputStreamReader() {
		if (mIn == null)
			mIn = new BufferedReader(new InputStreamReader(mProc.getInputStream()));
		return mIn;
	}

	public BufferedReader getErrorStreamReader() {
		if (mErr == null)
			mErr = new BufferedReader(new InputStreamReader(mProc.getErrorStream()));
		return mErr;
	}

	/**
	 * Get a line from the standard error.
	 * 
	 * @return If there's nothing in the standard error, this call will be
	 *         blocked. When the command execution is completed and all standard
	 *         error have been read, this call will return null.
	 */
	public String getErrorLine() throws IOException {
		if (mErr == null)
			mErr = new BufferedReader(new InputStreamReader(mProc.getErrorStream()));
		mTrace.log(Trace.DEBUG, "Before error readline");
		String line = mErr.readLine();
		mTrace.log(Trace.DEBUG, "After error readline");
		if (line == null)
			mErr.close();
		return line;
	}

	/**
	 * A convenient method to execute s system command and return all the
	 * (standard) output in a single String
	 * 
	 * @param cmd
	 *            the system command to be executed
	 */
	public static String getOutput(String cmd) throws IOException {
		BufferedReader in = null;

		Process proc = Runtime.getRuntime().exec(cmd);
		in = new BufferedReader(new InputStreamReader(proc.getInputStream()));

		// mTrace.log(Trace.DEBUG, "new CMD");
		// mTrace.log(Trace.DEBUG, "protocol " + CmdCmd.getProtocol());
		StringBuffer c = new StringBuffer();

		boolean more = true;
		while (more) {
			String line = in.readLine();
			if (line == null) {
				more = false;
			} else {
				c.append(line + "\n");
				// mTrace.log(Trace.DEBUG, line);
			}
		}
		in.close();
		return c.toString();

	}

}
