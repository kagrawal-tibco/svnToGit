package com.tibco.be.parser.codegen.stream;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.net.URI;

import javax.lang.model.element.NestingKind;
import javax.tools.JavaFileObject;
import javax.tools.SimpleJavaFileObject;

import com.tibco.be.parser.codegen.CGConstants;

/**
 * A JavaFileObject which contains either the source text or the compiler
 * generated class. This class is used in two cases.
 * <ol>
 * <li>This instance uses it to store the source which is passed to the
 * compiler. This uses the
 * {@link JavaFileObjectImpl#JavaFileObjectImpl(String, CharSequence)}
 * constructor.
 * <li>The Java compiler also creates instances (indirectly through the
 * FileManagerImplFileManager) when it wants to create a JavaFileObject for the
 * .class output. This uses the
 * {@link JavaFileObjectImpl#JavaFileObjectImpl(String, JavaFileObject.Kind, AbstractStreamGenerator)}
 * constructor.
 * </ol>
 * This class does not attempt to reuse instances (there does not seem to be a
 * need, as it would require adding a Map for the purpose, and this would also
 * prevent garbage collection of class byte code.)
 */
public final class JavaFileObjectImpl extends SimpleJavaFileObject {
	// If kind == CLASS, this stores byte code from openOutputStream
	// if kind == SOURCE, this contains the source text
	private ByteArrayOutputStream source;
	private String packageName;
	private String baseName;
	private AbstractStreamGenerator streamGenerator;
	private boolean libClass = false;

	/**
	 * Construct a new instance
	 * 
	 * @param name
	 *            the file name
	 * @param kind
	 *            the kind of file
	 * @param sg TODO
	 */
	public JavaFileObjectImpl(final String name, final Kind kind, AbstractStreamGenerator sg) {
		super(AbstractStreamGenerator.toURI(name), kind);
		this.streamGenerator = sg;
		this.packageName = "";
		this.baseName = name;
		source = new ByteArrayOutputStream();
		sg.debug(
				"Adding JavaFileObject -> package :{0} name:{1}  Kind:{2}",
				packageName, baseName, kind);
	}

	/**
	 * Construct a new instance which stores source
	 * @param baseName
	 *            the base name
	 * @param sg TODO
	 * @param source
	 *            the source code
	 */
	public JavaFileObjectImpl(final String packageName, final String baseName, AbstractStreamGenerator sg) {
		super(AbstractStreamGenerator.toURI(baseName), Kind.SOURCE);
		this.baseName = baseName;
		this.packageName = packageName;
		this.source = new ByteArrayOutputStream();
		this.streamGenerator = sg;
		getStreamGenerator().debug(
				"Adding JavaFileObject -> package :{0} name:{1}  Kind:{2}",
				packageName, baseName, kind);
	}
	
	/**
	 * Construct a new instance
	 * 
	 * @param name
	 *            the file name
	 * @param kind
	 *            the kind of file
	 */
	public JavaFileObjectImpl(final String packageName, final String name, final Kind kind) {
		super(AbstractStreamGenerator.toURI(name), kind);
		this.baseName = name;
		this.packageName = packageName;
		if(getStreamGenerator() != null) {
			
			getStreamGenerator().debug(
					"Adding JavaFileObject -> package :{0} name:{1}  Kind:{2}",
					packageName, baseName, kind);
		}
		source = new ByteArrayOutputStream();
	}

	/**
	 * @return the byte code generated by the compiler
	 */
	public byte[] getByteCode() {
		return source.toByteArray();
	}

	/**
	 * Return the source code content
	 * 
	 * @see javax.tools.SimpleJavaFileObject#getCharContent(boolean)
	 */
	@Override
	public CharSequence getCharContent(final boolean ignoreEncodingErrors)
			throws UnsupportedOperationException {
		if (source == null)
			throw new UnsupportedOperationException("getCharContent()");
		try {
			return new String(source.toByteArray(), "UTF-8");
		} catch (UnsupportedEncodingException e) {
			throw new UnsupportedOperationException("getCharContent()", e);
		}
	}

	@Override
	public NestingKind getNestingKind() {
		// TODO Auto-generated method stub
		return super.getNestingKind();
	}

	public String getPackageName() {
		return packageName;
	}

	/**
	 * @return
	 */
	public String getQualifiedName() {
		if (this.packageName != null && !this.packageName.isEmpty()) {
			return this.packageName + "." + this.baseName;
		} else {
			return this.baseName;
		}
	}

	public AbstractStreamGenerator getStreamGenerator() {
		return streamGenerator;
	}

	@Override
	public boolean isNameCompatible(String simpleName, Kind kind) {
		// TODO Auto-generated method stub
		return super.isNameCompatible(simpleName, kind);
	}

	/**
	 * Return an input stream for reading the byte code
	 * 
	 * @see javax.tools.SimpleJavaFileObject#openInputStream()
	 */
	@Override
	public InputStream openInputStream() {
		return new ByteArrayInputStream(getByteCode());
	}

	/**
	 * Return an output stream for writing the bytecode
	 * 
	 * @see javax.tools.SimpleJavaFileObject#openOutputStream()
	 */
	@Override
	public OutputStream openOutputStream() {
		return source;
	}
	
	@Override
	public Writer openWriter() throws IOException {
		return new OutputStreamWriter(openOutputStream(), CGConstants.charset);
	}

	@Override
	public String toString() {
		return packageName + "/" + this.baseName;
	}

	@Override
	public URI toUri() {
		return AbstractStreamGenerator.toURI(packageName + "/" + this.baseName);
	}

	public void setLibClass(boolean b) {
		libClass = true;		
	}
	
	public boolean isLibClass() {
		return libClass;
	}

}