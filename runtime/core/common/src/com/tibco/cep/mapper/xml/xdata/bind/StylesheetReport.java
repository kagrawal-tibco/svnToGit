package com.tibco.cep.mapper.xml.xdata.bind;

import java.io.StringWriter;
import java.util.ArrayList;

import org.xml.sax.SAXException;

import com.tibco.cep.mapper.xml.nsutils.NamespaceManipulationUtils;
import com.tibco.cep.mapper.xml.nsutils.SimpleNamespaceContextRegistry;
import com.tibco.cep.mapper.xml.xdata.xpath.ExprContext;
import com.tibco.cep.mapper.xml.xdata.xpath.VariableDefinition;
import com.tibco.cep.mapper.xml.xdata.xpath.VariableDefinitionList;
import com.tibco.cep.mapper.xml.xdata.xpath.type.XQueryTypesParser;
import com.tibco.xml.channel.infoset.XmlContentHandler;
import com.tibco.xml.data.primitive.ExpandedName;
import com.tibco.xml.data.primitive.NamespaceContextRegistry;
import com.tibco.xml.schema.SmSequenceType;
import com.tibco.xml.schema.xtype.SMDT;
import com.tibco.xml.serialization.DefaultXmlContentIndenter;
import com.tibco.xml.serialization.DefaultXmlContentSerializer;

/**
 * Replacement for BindingReport.
 * Generated by a Binding (template), this contains the computed types & error messages
 * for a Binding's formula.  A report applies to a single Binding & describes what is going to do, any errors that apply
 * to it, etc.
 */
public final class StylesheetReport
{
    private final StylesheetBinding mStylesheet;
    private final StylesheetContext mContext;

    private ExprContext mStylesheetEntryContext;
    private ArrayList mTemplateReports = new ArrayList();
    private ArrayList mTemplateSignatureReports = new ArrayList();
    private StylesheetResolver mTemplateResolver;

    public static StylesheetReport create(StylesheetBinding stylesheet, StylesheetContext stylesheetContext, TemplateReportArguments args) {
        return new StylesheetReport(stylesheet,stylesheetContext,new TemplateReportFormulaCache(),args,false);
    }

    public static StylesheetReport create(StylesheetBinding stylesheet, StylesheetContext stylesheetContext, TemplateReportFormulaCache formulaCache, TemplateReportArguments args, boolean templateSignaturesOnly) {
        return new StylesheetReport(stylesheet,stylesheetContext,formulaCache,args,templateSignaturesOnly);
    }

    private StylesheetReport(StylesheetBinding stylesheet,
                             StylesheetContext context,
                             TemplateReportFormulaCache formulaCache,
                             TemplateReportArguments args,
                             boolean templateSignaturesOnly) {
        mStylesheet = stylesheet;
        mContext = context;
        if (mContext==null) {
            throw new NullPointerException("Null context");
        }
        if (mContext.getComponentProvider()==null) {
            throw new NullPointerException("Null component provider");
        }

        analyzeStylesheetInput();
        analyzeTemplateSignatures();
        if (!templateSignaturesOnly) {
            buildTemplateResolver(context.getStylesheetResolver());
            analyzeTemplates(formulaCache,args);
        }
    }

    private void analyzeTemplateSignatures() {
        int cc = mStylesheet.getChildCount();
        for (int i=0;i<cc;i++) {
            Binding c = mStylesheet.getChild(i);
            if (c instanceof TemplateBinding) {
                analyzeTemplateSignature((TemplateBinding)c);
            }
        }
    }

    private void analyzeTemplateSignature(TemplateBinding template) {
        TemplateSignatureReport report = TemplateSignatureReport.create(template,mStylesheetEntryContext);//tec,mContext.getSchemaProvider(),args);
        mTemplateSignatureReports.add(report);
    }

    private void buildTemplateResolver(StylesheetResolver sr) {
        DefaultStylesheetResolver tr = new DefaultStylesheetResolver();
        tr.setChainTo(sr);
        TemplateSignatureReport[] res = getTemplateSignatureReports();
        for (int i=0;i<res.length;i++) {
            TemplateSignatureReport tsr = res[i];
            tr.addTemplate(tsr);
        }
        mTemplateResolver = tr;
    }

    private void analyzeTemplates(TemplateReportFormulaCache formulaCache, TemplateReportArguments args) {
        TemplateSignatureReport[] res = getTemplateSignatureReports();
        for (int i=0;i<res.length;i++) {
            analyzeTemplate(res[i],formulaCache,args);
        }
    }

    private void analyzeTemplate(TemplateSignatureReport tsr, TemplateReportFormulaCache formulaCache, TemplateReportArguments args) {
        ExprContext ec = tsr.createTemplateContextFrom(mStylesheetEntryContext);
        TemplateEditorConfiguration tec = new TemplateEditorConfiguration(ec,tsr.getOutput(),tsr.getTemplate());
        tec.setStylesheetResolver(mTemplateResolver);
        TemplateReport tr = TemplateReport.create(tec,formulaCache,args);
        mTemplateReports.add(tr);
    }

    private void analyzeStylesheetInput() {
        VariableDefinitionList varDefs = new VariableDefinitionList();
        int cc = mStylesheet.getChildCount();
        for (int i=0;i<cc;i++) {
            Binding b = mStylesheet.getChild(i);
            if (b instanceof ParamBinding) {
                ParamBinding pb = (ParamBinding) b;
                ExpandedName pn = pb.getParamName();
                SmSequenceType type = pb.computeType(mContext.getComponentProvider());

                VariableDefinition vd = new VariableDefinition(pn,type);
                varDefs.add(vd);
            }
        }
        String input = findComment(mStylesheet,"input");
        SmSequenceType dot;
        if (input==null) {
            // Context input is unknown.
            dot = SMDT.REPEATING_ITEM;
        } else {
            dot = XQueryTypesParser.parse(mStylesheet.asXiNode(),mContext.getComponentProvider(),SMDT.NONE,input);
        }

        ExprContext ec = new ExprContext(varDefs,dot,mContext.getFunctionResolver());
        ExprContext nec = ec.createWithInputAndOutputSchemaAndComponentProvider(
                null, mContext.getComponentProvider());
        ExprContext nec2 = nec.createWithNamespaceMapper(BindingNamespaceManipulationUtils.createChildNamespaceResolver(nec.getNamespaceMapper(),mStylesheet));
        mStylesheetEntryContext = nec2;
    }

    private static String findComment(Binding below, String startingWith) {
        int cc = below.getChildCount();
        for (int i=0;i<cc;i++) {
            Binding c = below.getChild(i);
            if (c instanceof CommentBinding) {
                CommentBinding cb = (CommentBinding) c;
                String str = cb.getComment().trim();
                if (str.trim().startsWith(startingWith)) {
                    return str.substring(startingWith.length());
                }
            }
        }
        return null;
    }

    public int getNumTemplateReports() {
        return mTemplateReports.size();
    }

    public TemplateSignatureReport getTemplateSignatureReport(int at) {
        return (TemplateSignatureReport) mTemplateSignatureReports.get(at);
    }

    public TemplateSignatureReport[] getTemplateSignatureReports() {
        return (TemplateSignatureReport[]) mTemplateSignatureReports.toArray(new TemplateSignatureReport[mTemplateReports.size()]);
    }

    public TemplateReport getTemplateReport(int at) {
        //mTemplateSignatureReports.get(at); // for range check only.
        //if (at<mTemplateReports.size())
        return (TemplateReport) mTemplateReports.get(at);
    }

    public TemplateReport[] getTemplateReports() {
        return (TemplateReport[]) mTemplateReports.toArray(new TemplateReport[mTemplateReports.size()]);
    }

    public void format(XmlContentHandler handler) throws SAXException {
        handler.startDocument();
        SimpleNamespaceContextRegistry extraNamespaces = new SimpleNamespaceContextRegistry();
        registerUndeclaredNamespaces(extraNamespaces);
        NamespaceManipulationUtils.issueNamespaceDeclarations(extraNamespaces,handler);
        formatFragment(handler,extraNamespaces);
        handler.endDocument();
    }

    public void registerUndeclaredNamespaces(NamespaceContextRegistry extraNamespaces) {
        extraNamespaces.getOrAddPrefixForNamespaceURI(TemplateReport.NAMESPACE,"rpt");
        registerUndeclaredNamespacesRecursive(extraNamespaces);
    }

    private void registerUndeclaredNamespacesRecursive(NamespaceContextRegistry extraNamespaces)
    {
        for (int i=0;i<mTemplateReports.size();i++)
        {
            TemplateReport tr = getTemplateReport(i);
            tr.formatNamespaces(extraNamespaces);
        }
    }

    public void formatFragment(XmlContentHandler handler, NamespaceContextRegistry extraNamespaces) throws SAXException {
        mStylesheet.issueNamespaceDeclarations(handler);
        handler.startElement(NAME_STYLESHEET,null,null);

        VariableDefinition[] vars = mStylesheetEntryContext.getVariables().getVariables();
        for (int i=0;i<vars.length;i++)
        {
            VariableDefinition vd = vars[i];
            handler.startElement(NAME_PARAM,null,null);
            handler.attribute(NAME_NAME,vd.getName(),null);
            handler.attribute(NAME_TYPE,vd.getType().formatAsSequenceType(mStylesheet.asXiNode()),null);
            handler.endElement(NAME_PARAM,null,null);
        }
        for (int i=0;i<mTemplateReports.size();i++)
        {
            TemplateReport tr = getTemplateReport(i);
            tr.formatFragment(handler,extraNamespaces);
        }

        handler.endElement(NAME_STYLESHEET,null,null);
    }

    public ExprContext getEntryContext() {
        return mStylesheetEntryContext;
    }

    private static final ExpandedName NAME_STYLESHEET = ExpandedName.makeName(TemplateReport.NAMESPACE,"stylesheet");
    private static final ExpandedName NAME_PARAM = ExpandedName.makeName(TemplateReport.NAMESPACE,"param");
    private static final ExpandedName NAME_NAME = ExpandedName.makeName("name");
    private static final ExpandedName NAME_TYPE = ExpandedName.makeName("type");

    /**
     * Formats in xml
     */
    public String toString() {
        StringWriter sw = new StringWriter();
        XmlContentHandler ch = new DefaultXmlContentIndenter(new DefaultXmlContentSerializer(sw,"UTF-8"));
        try {
            format(ch);
        } catch (SAXException se) {
            throw new RuntimeException("Format error: " + se.getMessage());
        }
        return sw.toString();
    }
}

