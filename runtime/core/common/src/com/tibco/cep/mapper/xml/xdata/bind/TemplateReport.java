package com.tibco.cep.mapper.xml.xdata.bind;

import java.io.StringWriter;
import java.util.ArrayList;
import java.util.Iterator;

import org.xml.sax.SAXException;

import com.tibco.cep.mapper.xml.nsutils.NamespaceManipulationUtils;
import com.tibco.cep.mapper.xml.xdata.DefaultNamespaceMapper;
import com.tibco.cep.mapper.xml.xdata.bind.virt.MarkerBinding;
import com.tibco.cep.mapper.xml.xdata.bind.virt.TypeCopyOfBinding;
import com.tibco.cep.mapper.xml.xdata.bind.virt.VirtualAttributeBinding;
import com.tibco.cep.mapper.xml.xdata.bind.virt.VirtualDataComponentCopyMode;
import com.tibco.cep.mapper.xml.xdata.bind.virt.VirtualElementBinding;
import com.tibco.cep.mapper.xml.xdata.xpath.ErrorMessage;
import com.tibco.cep.mapper.xml.xdata.xpath.ErrorMessageList;
import com.tibco.cep.mapper.xml.xdata.xpath.Expr;
import com.tibco.cep.mapper.xml.xdata.xpath.ExprContext;
import com.tibco.cep.mapper.xml.xdata.xpath.TextRange;
import com.tibco.cep.mapper.xml.xdata.xpath.func.TibExtFunctions;
import com.tibco.xml.channel.infoset.XmlContentHandler;
import com.tibco.xml.data.primitive.ExpandedName;
import com.tibco.xml.data.primitive.NamespaceContext;
import com.tibco.xml.data.primitive.NamespaceContextRegistry;
import com.tibco.xml.data.primitive.QName;
import com.tibco.xml.schema.SmComponentProviderEx;
import com.tibco.xml.schema.SmNamespace;
import com.tibco.xml.schema.SmNamespaceProvider;
import com.tibco.xml.schema.SmSchema;
import com.tibco.xml.schema.SmSequenceType;
import com.tibco.xml.schema.SmWildcard;
import com.tibco.xml.schema.helpers.SmComponentProviderExOnSmNamespaceProvider;
import com.tibco.xml.schema.xtype.helpers.SmSequenceTypeSupport;
import com.tibco.xml.serialization.DefaultXmlContentIndenter;
import com.tibco.xml.serialization.DefaultXmlContentSerializer;

/**
 * An analysis of a single XSLT instruction, in a tree structured mirroring that of the instructions ({@link Binding}).<br>
 * Generated by a Binding (template), this contains the computed types & error messages
 * for a Binding's formula.  A report applies to a single Binding & describes what is going to do, any errors that apply
 * to it, etc.<br>
 */
public final class TemplateReport
{
    private TemplateReport mParent;
    private final Binding mOn;
    private ArrayList mChildren; // null if none.
    private ArrayList mExtendedErrors; // null if none.
    private SmSequenceType mInitialOutputType; // The output BEFORE this binding that remains.
    private SmSequenceType mRemainingOutputType; // The output AFTER this binding that remains.
    private SmSequenceType mExpectedType;
    private SmSequenceType mComputedType;
    private SmSequenceType mFormulaType;
    private SmSequenceType mOutputContext; // On the right hand side, the context that this is being written into.
    private SmSequenceType mChildOutputContext;// On the right hand side, the context that the children are being written into.

    private ExprContext mContext; // The 'current' XPath position, optional, computed from above. For this node.
    private ExprContext mChildContext; // If a formula, the new 'current' XPath
    private ExprContext mFollowingContext; // The context for all elements following this one.

    private SharedTemplateReport m_sharedReport; // Contains common, per-template report information.

    // Errors:
    private ErrorMessageList mFormulaErrors = ErrorMessageList.EMPTY_LIST;
    private TemplateOutputContextError mOutputContextError; // Set if output doesn't belong (w.r.t. the schema here)
    private boolean mIsMissing; // set if this should exist but doesn't (i.e. a marker comment for a required element)
    private String mStructuralError; // set (to a message) if this binding doesn't belong (or is out of place)
    private String m_referencedSchemaError; // set (to a message) if the referenced schema is somehow messed up.
    private TemplateReport m_structuralErrorMoveTo; // optional when structural error present (o.w. always null), indicates a move that will fix the problem.
    private Expr mParsedExpr; // the parsed script on this, if any.
    private boolean mIsRecursivelyErrorFree; // Is the binding complete (not missing any subfields, etc.)?

    private ArrayList mMissingPrecedingTerms; // For this entry, those terms that aren't accounted for BEFORE this one.
    private boolean m_hasMissingPrecedingTerms; // Related to above, but when report is made without 'full fix', the entries aren't record, just this flag is set.

    private ArrayList mMissingEndingTerms; // For this entry, those terms that, in its children, aren't accounted for in this one.
    private boolean m_hasMissingEndingTerms; // For this entry, those terms that, in its children, aren't accounted for in this one.

    private ArrayList mMissingFollowingTerms; // For this entry, those terms that, in one or more of the paths that can be taken, aren't accounted for at the end.
    private ArrayList mPrecedingMovedFrom; // For this entry, parallels mMissingPrecedingTerms, has the 'move to' state.

    private TemplateReport m_movedFrom;
    private TemplateReport mMoveToMissingPreceding; // for a 'move', indicates where.
    private int mMoveToMissingPrecedingIndex; // for a 'move', indicates which index it moves to.

    private ExpandedName mRenameTo; // If a rename fixes problems.

    /**
     * For template report printing.
     */
    public static final String NAMESPACE = "http://www.tibco.com/ns/template-report";

    private static final SmSequenceType[] EMPTY_XTYPE_ARRAY = new SmSequenceType[0];
    private static final TemplateReportExtendedError[] EMPTY_EXTENDED_ERRORS = new TemplateReportExtendedError[0];

    private boolean mIsLocked;

   public TemplateReport(Binding on, TemplateReport parent) {
      this(on, parent, true);
   }

   public TemplateReport(Binding on, TemplateReport parent, boolean addToParent) {
        if (on==null)
        {
            throw new IllegalArgumentException("Null on");
        }
        mOn = on;
        mParent = parent;
        if (parent!=null)
        {
           if(addToParent) {
              parent.addChild(this);
           }
            m_sharedReport = parent.getSharedTemplateReport();
        }
        else
        {
            m_sharedReport = new SharedTemplateReport();
        }
    }

    /**
     * @param config is the state of the XSLT template environment at the point in time this Binding would be executed.
     */
    public static TemplateReport create(TemplateEditorConfiguration config, TemplateReportFormulaCache formulaCache, TemplateReportArguments templateReportArguments) {
        if (config==null) {
            throw new NullPointerException("Null config");
        }
        if (config.getExprContext().getOutputSchemaProvider()==null)
        {
            throw new NullPointerException("Null output schema provider");
        }
        final SmSequenceType output;
        if (config.getExpectedOutput()==null) { // just deal with it.
            throw new RuntimeException("Shouldn't happen, null expected output");
        }
        output = config.getExpectedOutput();

        // Do all the grunt-work preparing the ExprContext.
        NamespaceContextRegistry nr = BindingNamespaceManipulationUtils.createNamespaceImporter(config.getBinding());
        NamespaceContextRegistry newNamespaceResolver = BindingNamespaceManipulationUtils.createChildNamespaceResolver(nr,config.getBinding());
        ExprContext ec = config.getExprContext().createWithNamespaceMapper(newNamespaceResolver);
        SmNamespaceProvider outputProvider = new OutputSmNamespaceProvider(config.getExprContext().getOutputSchemaProvider(),SmSequenceTypeSupport.getContainingSchema(output));
        SmComponentProviderEx outputCompProvider = new SmComponentProviderExOnSmNamespaceProvider(outputProvider);
        ExprContext spec = ec.createWithOutputSchemaAndComponentProvider(outputProvider,
                                                                         outputCompProvider)
                .createWithInputSchemaAndComponentProvider(ec.getOutputSchemaProvider(),
                                                           ec.getOutputSmComponentProvider());
        ExprContext coercedec = config.getCoercionSet().applyTo(spec);
        ExprContext finalec = coercedec.createWithStylesheetResolver(config.getStylesheetResolver());

        // Use the expected output as the initial output context; in the case of a choice of local elements, etc., we
        // absolutely need this.  If it happens to be, in the normal case, just a regular element there is no harm ---
        // when finding elements in context it will only search that element name (not its children).
        SmSequenceType initialOutputContext = output;

        TemplateReport tr = config.getBinding().createTemplateReport(null, finalec, output, initialOutputContext, SmWildcard.STRICT, formulaCache, templateReportArguments);
        // don't bother locking; also creates problems with GUI.tr.lock();

        CoercionChecker.checkCoercions(config.getCoercionSet(),spec,tr);

        return tr;
    }

    static class OutputSmNamespaceProvider implements SmNamespaceProvider {
        private SmSchema mSchema;
        private SmNamespaceProvider mChainTo;

        public OutputSmNamespaceProvider(SmNamespaceProvider chainTo, SmSchema schema) {
            mSchema = schema;
            mChainTo = chainTo;
            if (chainTo==null)
            {
                throw new NullPointerException();
            }
        }

        /**
         * @deprecated
         */
        public Iterator getNamespaces()
        {
            throw new IllegalArgumentException();
        }

        public SmNamespace getNamespace(String namespace)
        {
            if (namespace==null || namespace.equals("")) {
                if (mSchema!=null) {
                    if (mSchema.getNamespace()==null || mSchema.getNamespace().equals("")) {
                        return mSchema;
                    }
                }
            } else {
                if (mSchema!=null) {
                    if (mSchema.getNamespace()!=null && mSchema.getNamespace().equals(namespace)) {
                        return mSchema;
                    }
                }
            }
            // otherwise, pass on:
            return mChainTo.getNamespace(namespace);
        }
    };

    public TemplateReport getPrecedingMovedFrom(int i) {
        if (mPrecedingMovedFrom==null) {
            return null;
        }
        return (TemplateReport) mPrecedingMovedFrom.get(i);
    }

    /**
     * Generates a BindingReport from this Binding.
     */
    public TemplateReport getTemplateReport(ExprContext context, SmSequenceType term, SmNamespaceProvider provider, int sourceVersionNumber)
    {
        if (term==null) {
            throw new NullPointerException("Null binding term");
        }
        // Now create the BindingReport from the binding.
        //BindingReport report = this.generateBindingReport(null, context, new HashSet(),sourceVersionNumber);
        return null;//report;
    }

    public TemplateReport getParent() {
        return mParent;
    }

    /**
     * Returns the Binding this report is describing.
     */
    public Binding getBinding() {
        return mOn;
    }

    /**
     * This is the type 'declared' (by inference from the relevant schema) that this template generates.
     * @return The expected type, never null (after report is built)
     */
    public SmSequenceType getExpectedType()
    {
        return mExpectedType;
    }

    public void setExpectedType(SmSequenceType type) {
        if (mIsLocked)
        { // sanity.
            throw new IllegalStateException("locked");
        }
        mExpectedType = type;
    }

    /**
     * Sets the message for a structural error.<br>
     * A structural error indicates that the binding didn't belong there at an XML validation level;
     * i.e. a 'when' not under a 'choose'.
     * @param errorMessage The message, or null for none.
     */
    public void setStructuralError(String errorMessage)
    {
        if (mIsLocked)
        { // sanity.
            throw new IllegalStateException("locked");
        }
        mStructuralError = errorMessage;
    }

    /**
     * Gets the errors message (if any) describing the structural error.<br>
     * A structural error indicates that the binding didn't belong there at an XML validation level;
     * i.e. a 'when' not under a 'choose'.
     * @return The error message, or null for none.
     */
    public String getStructuralError()
    {
        return mStructuralError;
    }

    public void setStructuralError(String s, TemplateReport moveTo)
    {
        if (mIsLocked) { // sanity.
            throw new IllegalStateException("locked");
        }
        mStructuralError = s;
        m_structuralErrorMoveTo = moveTo;
    }

    /**
     * A {@link #getStructuralError} may also have a move to position to fix it (optional).
     */
    public TemplateReport getStructuralErrorMoveTo()
    {
        return m_structuralErrorMoveTo;
    }

    /**
     * Sets an error messaging indicating that the referenced schema has an error.
     * @param msg The error message, or null for none.
     */
    public void setReferencedSchemaError(String msg)
    {
        m_referencedSchemaError = msg;
    }

    /**
     * Gets an error messaging indicating that the referenced schema has an error.
     * @return The error message, or null for none.
     */
    public String getReferencedSchemaError()
    {
        return m_referencedSchemaError;
    }

    /**
     * This is the type computed (by inference from the relevant schema and xpaths) that this template will actually
     * generate.<br>
     * For this to be valid, the computed type must be a subtype of the expected type, otherwise it is an incorrect
     * (can't be validated) xslt template.<br>
     * @return The computed type, never null (after report is built)
     */
    public SmSequenceType getComputedType() {
        return mComputedType;
    }

    public void setComputedType(SmSequenceType type) {
        if (mIsLocked) { // sanity.
            throw new IllegalStateException("locked");
        }
        mComputedType = type;
    }

    /**
     * This is the type computed by the xpath formula (or equivalent) on the node, if any, null otherwise.
     * @return The type, or null if not applicable.
     */
    public SmSequenceType getFormulaType() {
        return mFormulaType;
    }

    public void setFormulaType(SmSequenceType type) {
        if (mIsLocked) {
            throw new IllegalStateException("locked");
        }
        mFormulaType = type;
    }

    /**
     * Gets the next report, or null for none.
     * @return The next report.
     */
    public TemplateReport getNext()
    {
        if (getParent()==null)
        {
            return null;
        }
        int ioc = getParent().getIndexOfChild(this);
        if (ioc+1<getChildCount())
        {
            return getChild(ioc+1);
        }
        return null;
    }

    public int getIndexOfChild(TemplateReport child) {
        for (int i=0;i<getChildCount();i++) {
            if (getChild(i)==child) {
                return i;
            }
        }
        return -1;
    }

    /**
     * Computed, checks if this has {@link #getMissingEndingTerms()} or if any child has {@link #getMissingPrecedingTerms()}.<br>
     * Does <b>not</b> check for unfilled (required) marker bindings.
     */
    public boolean hasMissingOutputErrors() {
        if (getHasMissingEndingTerms()) {
            return true;
        }
        for (int i=0;i<getChildCount();i++) {
            TemplateReport c = getChild(i);
            if (c.getHasMissingPrecedingTerms()) {
                return true;
            }
        }
        return false;
    }

    /**
     * Computed, checks if any child has {@link #getIsMissing()}.
     */
    public boolean hasMissingChildren() {
        for (int i=0;i<getChildCount();i++) {
            TemplateReport c = getChild(i);
            if (c.getIsMissing()) {
                return true;
            }
        }
        return false;
    }

    /**
     * Computed, checks if any child has {@link #getOutputContextError()}.
     */
    public boolean containsOutputContextError() {
        for (int i=0;i<getChildCount();i++) {
            TemplateReport c = getChild(i);
            if (c.getOutputContextError()!=null) {
                return true;
            }
        }
        return false;
    }

//    public Expr buildRunnerExpr() {
//        return BindingRunnerGen.buildRunnerExpr(this);
//    }


    /**
     * Is the binding complete? i.e. does it have all the values it needs.
     */
    public boolean isRecursivelyErrorFree() {
        return mIsRecursivelyErrorFree;
    }

    public void setIsRecursivelyErrorFree(boolean val) {
        if (mIsLocked) { // sanity.
            throw new IllegalStateException("locked");
        }
        mIsRecursivelyErrorFree = val;
    }

    protected void addChild(TemplateReport report) {
        if (mIsLocked) { // sanity.
            throw new IllegalStateException("locked");
        }
        if (mChildren==null) {
            mChildren = new ArrayList();
        }
        mChildren.add(report);
    }

    public boolean hasChildren() {
        return mChildren!=null;
    }

    public TemplateReport getChildFor(Binding binding) {
        if (mChildren==null) {
            return null;
        }
        for (int i=0;i<mChildren.size();i++) {
            TemplateReport r = (TemplateReport) mChildren.get(i);
            if (r.getBinding()==binding) {
                return r;
            }
        }
        return null;
    }

    /**
     * For bindings that are {@link #getOutputContextError}, a suggested move-to spot can be found, if so this
     * and {@link #getMoveToPrecedingIndex()} will be set
     * @return The report where the location of the move to is found.
     */
    public TemplateReport getMoveToPreceding() {
        return mMoveToMissingPreceding;
    }

    public int getMoveToPrecedingIndex() {
        return mMoveToMissingPrecedingIndex;
    }

    public TemplateReport getChild(int at) {
        return (TemplateReport) mChildren.get(at);
    }

    public TemplateReport[] getChildren() {
        if (mChildren==null) {
            return new TemplateReport[0];
        }
        return (TemplateReport[]) mChildren.toArray(new TemplateReport[mChildren.size()]);
    }

    public void setContext(ExprContext context)
    {
        if (mIsLocked)
        { // sanity.
            throw new IllegalStateException("locked");
        }
        if (context==null)
        {
            throw new NullPointerException("Null context set");
        }
        mContext = context;
        if (context.getInputSchemaProvider()==null)
        {
            throw new NullPointerException("Null input sp");
        }
        if (context.getOutputSchemaProvider()==null)
        {
            throw new NullPointerException("Null output sp");
        }
    }

    /**
     * The type from which the XPath evaluation takes place for THIS formula.
     */
    public ExprContext getContext() {
        return mContext;
    }


    /**
     * The type from which the XPath evaluation takes place for child formula.
     */
    public ExprContext getChildContext() {
        return mChildContext;
    }

    public void setChildContext(ExprContext context) {
        if (mIsLocked) { // sanity.
            throw new IllegalStateException("locked");
        }
        mChildContext = context;
    }

    /**
     * The type from which the XPath evaluation takes place for all following formula.
     */
    public ExprContext getFollowingContext() {
        return mFollowingContext;
    }

    public void setFollowingContext(ExprContext context) {
        if (mIsLocked) { // sanity.
            throw new IllegalStateException("locked");
        }
        mFollowingContext = context;
    }

    /**
     * The context in which the output occurs (i.e. if this binding is inside of element 'fred', the context is fred)
     * @return The output context, or null if none found.
     */
    public SmSequenceType getOutputContext() {
        return mOutputContext;
    }

    public void setOutputContext(SmSequenceType dc) {
        if (mIsLocked) { // sanity.
            throw new IllegalStateException("locked");
        }
        mOutputContext = dc;
    }

    /**
     * Retrieves the portion of the report that is common for the entire template.
     * @return
     */
    public SharedTemplateReport getSharedTemplateReport()
    {
        return m_sharedReport;
    }

    /**
     * The context in which the output this node's children occurs (i.e. if this binding is inside of element 'fred', the context is fred).<br>
     * Note that this is often the same as {@link #getComputedType()}, for example, on an element.
     * @return The output context, or null if none found.
     */
    public SmSequenceType getChildOutputContext() {
        return mChildOutputContext;
    }

    public void setChildOutputContext(SmSequenceType dc) {
        if (mIsLocked) { // sanity.
            throw new IllegalStateException("locked");
        }
        mChildOutputContext = dc;
    }

    public ErrorMessageList getFormulaErrors() {
        return mFormulaErrors;
    }

    /**
     * Set if this binding doesn't belong here in the output.
     */
    public TemplateOutputContextError getOutputContextError() {
        return mOutputContextError;
    }

    public void setOutputContextError(TemplateOutputContextError val) {
        if (mIsLocked) { // sanity.
            throw new IllegalStateException("locked");
        }
        mOutputContextError = val;
    }

    /*public void setErrors(ErrorMessageList errors) {
        if (errors==null) {
            throw new IllegalArgumentException("Setting errors null");
        }
        if (mErrors!=null) {
            throw new IllegalStateException("Resetting errors, use append errors");
        }
        mErrors = errors;
    }*/

    public void addFormulaErrors(ErrorMessageList errors) {
        if (mIsLocked) { // sanity.
            throw new IllegalStateException("locked");
        }
        mFormulaErrors = mFormulaErrors.addMessages(errors);
    }

    /**
     * Formats in xml
     */
    public String toString() {
        StringWriter sw = new StringWriter();
        XmlContentHandler ch = new DefaultXmlContentIndenter(new DefaultXmlContentSerializer(sw,"UTF-8"));
        try {
            format(ch);
        } catch (SAXException se) {
            throw new RuntimeException("Format error: " + se.getMessage());
        }
        return sw.toString();
    }


    public void setMovedToMissingPreceding(TemplateReport previousReport, int j) {
        mMoveToMissingPreceding = previousReport;
        mMoveToMissingPrecedingIndex = j;
    }

    /**
     * Returns the preparsed script, if any.
     * @return The parsed xpath expression, or null if none.
     */
    public Expr getXPathExpression() {
        return mParsedExpr;
    }

    public void setXPathExpression(Expr expr) {
        mParsedExpr = expr;
    }

    /**
     * Simple helper fn., returns the range of the formula.
     */
    public TextRange computeFormulaRange() {
        String formula = getBinding().getFormula();
        if (formula==null) {
            return new TextRange(0,0);
        }
        return new TextRange(0,formula.length());
    }
    /**
     * Gets the number of child reports available.  This should match exactly what the referenced {@link #getBinding()}
     * child count is.
     * @return The number of children.
     */
    public int getChildCount()
    {
        if (mChildren == null) {
            return 0;
        }
        return mChildren.size();
    }

    /**
     * Adds an XType to an ordered list of XTypes (terms) that should have appeared BEFORE this one, but didn't.<br>
     * Note that, when not run with full fix analysis, instead of adding the terms, the report will just set
     * {@link #setHasMissingPrecedingTerms}.
     * @see #getHasMissingPrecedingTerms
     */
    public void addMissingPrecedingTerm(SmSequenceType xType) {
        if (mIsLocked)
        {
            throw new IllegalStateException("Locked");
        }
        if (mMissingPrecedingTerms==null)
        {
            mMissingPrecedingTerms = new ArrayList();
        }
        if (xType==null)
        {
            throw new NullPointerException();
        }
        m_hasMissingPrecedingTerms = true;
        mMissingPrecedingTerms.add(xType);
    }

    public void setHasMissingPrecedingTerms(boolean val)
    {
        m_hasMissingPrecedingTerms = true;
    }

    public boolean getHasMissingPrecedingTerms()
    {
        return m_hasMissingPrecedingTerms;
    }

    /**
     * Clears all missing preceding terms.  Used for 'bubbling-up' missing preceding terms (through ifs, choose, etc.)
     */
    public void removeAllMissingPrecedingTerms() {
        if (mIsLocked) {
            throw new IllegalStateException("Locked");
        }
        mMissingPrecedingTerms=null;
        m_hasMissingPrecedingTerms = false;
    }

    public void addExtendedError(TemplateReportExtendedError error)
    {
        if (mExtendedErrors==null)
        {
            mExtendedErrors = new ArrayList();
        }
        mExtendedErrors.add(error);
    }

    public boolean hasExtendedErrors()
    {
        return mExtendedErrors!=null;
    }

    public TemplateReportExtendedError[] getExtendedErrors()
    {
        if (mExtendedErrors==null)
        {
            return EMPTY_EXTENDED_ERRORS;
        }
        return (TemplateReportExtendedError[]) mExtendedErrors.toArray(new TemplateReportExtendedError[mExtendedErrors.size()]);
    }

    /**
     * Records the moved from position.
     * @param precedingMissingPosition The missing preceding position, or -1, to indicate that this is a marker.
     * @param report The report that it moved from.
     */
    public void setMovedFrom(int precedingMissingPosition, TemplateReport report) {
        if (mIsLocked) {
            throw new IllegalStateException("Locked");
        }
        if (mPrecedingMovedFrom==null)
        {
            mPrecedingMovedFrom = new ArrayList();
        }
        int tl = getMissingPrecedingTerms().length;
        if (precedingMissingPosition>=tl)
        {
            throw new IllegalArgumentException("Out of range");
        }
        while (mPrecedingMovedFrom.size()<tl)
        {
            mPrecedingMovedFrom.add(null);
        }
        if (precedingMissingPosition==-1)
        {
            // do nothing for now.
            m_movedFrom = report;
        }
        else
        {
            mPrecedingMovedFrom.set(precedingMissingPosition,report);
        }
    }

    /**
     * If a move is detected that would move on this node (which is a marker), then this is set to the moved node.
     * @return
     */
    public TemplateReport getMovedFrom()
    {
        return m_movedFrom;
    }

    /**
     * Adds an XType to an ordered list of XTypes (terms) that should have appeared at the end of the children list, but didn't.
     */
    public void addMissingEndingTerm(SmSequenceType xType)
    {
        if (mIsLocked)
        {
            throw new IllegalStateException("Locked");
        }
        if (mMissingEndingTerms==null) {
            mMissingEndingTerms = new ArrayList();
        }
        mMissingEndingTerms.add(xType);
        m_hasMissingEndingTerms = true;
    }

    /**
     * Sets a flag that there is an XTypes (terms) that should have appeared at the end of the children list, but didn't.
     */
    public void setHasMissingEndingTerms(boolean val) {
        if (mIsLocked) {
            throw new IllegalStateException("Locked");
        }
        if (!val && mMissingEndingTerms!=null)
        {
            throw new IllegalStateException("Already added missing ending terms");
        }
        m_hasMissingEndingTerms = val;
    }

    public boolean getHasMissingEndingTerms()
    {
        return m_hasMissingEndingTerms;
    }

    /**
     * Adds an XType to an ordered list of XTypes (terms) that should may not be handled in all cases (i.e. if, choose).
     */
    public void addMissingFollowingTerm(SmSequenceType xType) {
        if (mIsLocked) {
            throw new IllegalStateException("Locked");
        }
        if (mMissingFollowingTerms==null) {
            mMissingFollowingTerms = new ArrayList();
        }
        mMissingFollowingTerms.add(xType);
    }

    /**
     * Indicates if there are any missing following terms on this report.
     * @return
     */
    public boolean getHasMissingFollowingTerms()
    {
        return mMissingFollowingTerms!=null;
    }

    public SmSequenceType[] getMissingEndingTerms() {
        if (mMissingEndingTerms==null) {
            return EMPTY_XTYPE_ARRAY;
        }
        return (SmSequenceType[]) mMissingEndingTerms.toArray(new SmSequenceType[mMissingEndingTerms.size()]);
    }

    public SmSequenceType[] getMissingPrecedingTerms() {
        if (mMissingPrecedingTerms==null) {
            return EMPTY_XTYPE_ARRAY;
        }
        return (SmSequenceType[]) mMissingPrecedingTerms.toArray(new SmSequenceType[mMissingPrecedingTerms.size()]);
    }

    public SmSequenceType[] getMissingFollowingTerms() {
        if (mMissingFollowingTerms==null) {
            return EMPTY_XTYPE_ARRAY;
        }
        return (SmSequenceType[]) mMissingFollowingTerms.toArray(new SmSequenceType[mMissingFollowingTerms.size()]);
    }

    public void removeLastMissingFollowingTerms()
    {
        mMissingFollowingTerms.remove(mMissingFollowingTerms.size()-1);
        if (mMissingFollowingTerms.size()==0)
        {
            mMissingFollowingTerms = null;
        }
    }

    public void lock() {
        if (mIsLocked) {
            return;
        }
        if (mRemainingOutputType==null) {
            System.err.println("Remaining type null on " + mOn.getClass().getName());
        }
        if (mInitialOutputType==null) {
            System.err.println("Initial type null on " + mOn.getClass().getName() + (mOn.getParent()==null ? "" : " parent " + mOn.getParent().getClass()));
        }
        /* WCETODO Re-add if (mFormulaType!=null) {
            if (mExpectedType==null) {
                System.err.println("Expected type null, formula type non-null on " + mOn.getClass().getName());
            }
        }*/
        mIsLocked = true;
        if (mChildren!=null) {
            for (int i=0;i<mChildren.size();i++) {
                getChild(i).lock();
            }
        }
    }

    /**
     * Gets the type of the output that remains <b>after</b> this binding.
     * @return The type, never null.
     */
    public SmSequenceType getInitialOutputType() {
        return mInitialOutputType;
    }

    public void setInitialOutputType(SmSequenceType type) {
        if (mIsLocked) {
            throw new IllegalStateException("locked");
        }
        mInitialOutputType = type;
    }

    /**
     * Gets the type of the output that remains <b>after</b> this binding.
     * @return The type, never null.
     */
    public SmSequenceType getRemainingOutputType() {
        return mRemainingOutputType;
    }

    public void setRemainingOutputType(SmSequenceType type) {
        if (mIsLocked) {
            throw new IllegalStateException("locked");
        }
        mRemainingOutputType = type;
    }

    public void setRenameTo(ExpandedName name) {
        if (mIsLocked) {
            throw new IllegalStateException();
        }
        mRenameTo = name;
    }

    public void setIsMissing(boolean val) {
        mIsMissing = val;
    }

    /**
     * Will be set on marker comments for required elements, otherwise false.
     */
    public boolean getIsMissing() {
        return mIsMissing;
    }

    /**
     * If {@link #getOutputContextError} is true, this may be set to a name which will 'fit'.
     * @return The name or none.
     */
    public ExpandedName getRenameTo() {
        return mRenameTo;
    }

    public void format(XmlContentHandler handler) throws SAXException {
        handler.startDocument();
        DefaultNamespaceMapper extraNamespaces = new DefaultNamespaceMapper();
        formatNamespaces(extraNamespaces);
        extraNamespaces.writePrefixes(handler);
        mOn.issueNamespaceDeclarations(handler);
        handler.startElement(REPORT_NAME,null,null);
        formatFragment(handler,extraNamespaces);
        handler.endElement(REPORT_NAME,null,null);
        handler.endDocument();
    }

    public void formatNamespaces(NamespaceContextRegistry extraNamespaces) {
        extraNamespaces.getOrAddPrefixForNamespaceURI(NAMESPACE,"rpt");
        formatNamespaceRecursive(extraNamespaces);
    }

    private void formatNamespaceRecursive(NamespaceContextRegistry extraNamespaces)
    {
        NamespaceContextRegistry nm = NamespaceManipulationUtils.createNamespaceImporter(mOn.asXiNode(),extraNamespaces);
        if (mMissingPrecedingTerms!=null) {
            for (int i=0;i<mMissingPrecedingTerms.size();i++) {
                SmSequenceType xt = (SmSequenceType) mMissingPrecedingTerms.get(i);
                xt.registerAllNamespaces(nm);
            }
        }
        if (mOn instanceof DataComponentBinding) {
            DataComponentBinding eb = (DataComponentBinding) mOn;
            if (eb.isExplicitXslRepresentation())
            {
                nm.getOrAddPrefixForNamespaceURI(ReadFromXSLT.XSLT_URI);
            }
            ExpandedName ename = mOn.getName();
            nm.getOrAddPrefixForNamespaceURI(ename.getNamespaceURI());
        }
        if (mOn instanceof MarkerBinding)
        {
            nm.getOrAddPrefixForNamespaceURI(TibExtFunctions.NAMESPACE,"tib");
        }
        if (mExpectedType!=null)
        {
            mExpectedType.registerAllNamespaces(nm);
        }
        if (mComputedType!=null)
        {
            mComputedType.registerAllNamespaces(nm);
        }
        if (mFormulaType!=null)
        {
            mFormulaType.registerAllNamespaces(nm);
        }
        if (mRenameTo!=null) {
            nm.getOrAddPrefixForNamespaceURI(mRenameTo.getNamespaceURI());
        }
        if (mExtendedErrors!=null)
        {
            for (int i=0;i<mExtendedErrors.size();i++)
            {
                TemplateReportExtendedError e = (TemplateReportExtendedError) mExtendedErrors.get(i);
                e.registerNamespaces(nm);
            }
        }
        for (int i=0;i<getChildCount();i++) {
            getChild(i).formatNamespaceRecursive(extraNamespaces);
        }
        if (mMoveToMissingPreceding!=null)
        {
            nm.getOrAddPrefixForNamespaceURI(mMoveToMissingPreceding.getBinding().getName().getNamespaceURI());
        }
        if (mMissingEndingTerms!=null) {
            for (int i=0;i<mMissingEndingTerms.size();i++) {
                SmSequenceType xt = (SmSequenceType) mMissingEndingTerms.get(i);
                xt.registerAllNamespaces(nm);
            }
        }
        if (mMissingFollowingTerms!=null) {
            for (int i=0;i<mMissingFollowingTerms.size();i++) {
                SmSequenceType xt = (SmSequenceType) mMissingFollowingTerms.get(i);
                xt.registerAllNamespaces(nm);
            }
        }
    }

    public void formatFragment(XmlContentHandler handler, NamespaceContextRegistry extraNamespaces) throws SAXException {
        NamespaceContext nc = NamespaceManipulationUtils.createChainingContext(mOn.asXiNode(),extraNamespaces);
        if (mMissingPrecedingTerms!=null) {
            for (int i=0;i<mMissingPrecedingTerms.size();i++) {
                SmSequenceType xt = (SmSequenceType) mMissingPrecedingTerms.get(i);
                String t = xt.formatAsSequenceType(mOn.asXiNode());
                handler.startElement(MISSING,null,null);
                handler.attribute(TYPE_ATTR,t,null);
                if (getPrecedingMovedFrom(i)!=null) {
                    handler.attribute(MOVED_TO_ATTR,"true",null);
                }
                handler.endElement(MISSING,null,null);
            }
        }
        ExpandedName elName;
        if (mOn instanceof AttributeBinding)
        {
            elName = AttributeBinding.NAME;
        }
        else
        {
            elName = mOn.getName();
        }
        handler.startElement(elName,null,null);
        if (mOn instanceof DataComponentBinding)
        {
            DataComponentBinding eb = (DataComponentBinding)mOn;
            if (eb.isExplicitXslRepresentation())
            {
                String ftns = eb.getExplicitNamespaceAVT();
                if (ftns!=null)
                {
                    handler.attribute(NAMESPACE_ATTR,ftns,null);
                }
                String ftn = eb.getExplicitNameAVT();
                if (ftn==null)
                {
                    ftn = "";
                }
                handler.attribute(NAME_ATTR,ftn,null);
            }
            else
            {
                if (eb instanceof AttributeBinding)
                {
                    QName qn = eb.getName().getQName(nc);
                    handler.attribute(NAME_ATTR,qn.toString(),null);
                }
            }
        }
        if (mOn instanceof VirtualElementBinding)
        {
            VirtualElementBinding veb = (VirtualElementBinding) mOn;
            if (veb.isExplicitNil())
            {
                handler.attribute(EXPLICIT_NIL_ATTR,"true",null);
            }
            VirtualDataComponentCopyMode cm = veb.getCopyMode();
            if (cm!=VirtualDataComponentCopyMode.REQUIRED_TO_REQUIRED)
            {
                handler.attribute(COPY_MODE_ATTR,cm.toString(),null);
            }
        }
        if (mOn instanceof VirtualAttributeBinding)
        {
            VirtualAttributeBinding veb = (VirtualAttributeBinding) mOn;
            if (veb.getCopyMode()!=VirtualDataComponentCopyMode.REQUIRED_TO_REQUIRED)
            {
                handler.attribute(COPY_MODE_ATTR,veb.getCopyMode().toString(),null);
            }
        }
        if (mOn instanceof TypeCopyOfBinding)
        {
            handler.attribute(TYPE_COPY_OF_ATTR,"true",null);
        }
        if (mExpectedType!=null)
        {
            if (!(mOn instanceof ForEachBinding) && !(mOn instanceof ForEachGroupBinding) && !(mOn instanceof ChooseBinding) && !(mOn instanceof WhenBinding) && !(mOn instanceof OtherwiseBinding) && !(mOn instanceof IfBinding)) //WCETODO figure out what to do --- maybe just leave in & adjust testcase formatting.
            {
                String etype = mExpectedType.formatAsSequenceType(nc);
                if (etype.endsWith("#"))
                {
                    etype = etype.substring(0,etype.length()-1); // formatting for backward-compat... ugly.
                }
                handler.attribute(EXPECTED_TYPE,etype,null);
            }
        }
        if (mComputedType!=null)
        {
            String ctype = mComputedType.formatAsSequenceType(nc);
            handler.attribute(COMPUTED_TYPE,ctype,null);
        }
        if (mFormulaType!=null) {
            String ctype = mFormulaType.formatAsSequenceType(nc);
            handler.attribute(FORMULA_TYPE,ctype,null);
        }
        if (mStructuralError!=null) {
            handler.attribute(STRUCTURAL_ERROR,mStructuralError,null);
        }
        if (m_referencedSchemaError!=null)
        {
            handler.attribute(REFERENCED_SCHEMA_ERROR,m_referencedSchemaError,null);
        }
        if (m_structuralErrorMoveTo!=null) {
            String s = m_structuralErrorMoveTo.getBinding().getName().getQName(nc).toString();
            handler.attribute(STRUCTURAL_MOVE_TO,s,null);
        }
        if (mOutputContextError!=null)
        {
            if (mOutputContextError==TemplateOutputContextError.CARDINALITY)
            {
                handler.attribute(CONTEXT_CARDINALITY_ERROR,"true",null);
            }
            else
            {
                // Just lump all the others into one field for now:
                handler.attribute(CONTEXT_ERROR,"true",null);
            }
        }
        if (mMoveToMissingPreceding!=null) {
            String s = mMoveToMissingPreceding.getBinding().getName().getQName(nc) + ":" + mMoveToMissingPrecedingIndex;
            handler.attribute(MOVE_TO,s,null);
        }
        if (mRenameTo!=null) {
            QName qname = mRenameTo.getQName(nc);
            handler.attribute(RENAME_TO,qname.toString(),null);
        }
        if (!mIsRecursivelyErrorFree) {
            handler.attribute(COMPLETE,"false",null);
        }

        StringBuffer sb = new StringBuffer();
        formatErrors(sb);
        String err = sb.toString();
        if (err.length()>0) {
            handler.attribute(ERRORS,err,null);
        }
        if (mExtendedErrors!=null)
        {
            for (int i=0;i<mExtendedErrors.size();i++)
            {
                TemplateReportExtendedError e = (TemplateReportExtendedError) mExtendedErrors.get(i);
                e.formatFragment(handler, nc);
            }
        }
        formatChildren(handler,extraNamespaces);
        if (mMissingEndingTerms!=null) {
            for (int i=0;i<mMissingEndingTerms.size();i++) {
                SmSequenceType xt = (SmSequenceType) mMissingEndingTerms.get(i);
                String t = xt.formatAsSequenceType(nc);
                handler.startElement(MISSING,null,null);
                handler.attribute(TYPE_ATTR,t,null);
                handler.endElement(MISSING,null,null);
            }
        }
        handler.endElement(elName,null,null);
        if (mMissingFollowingTerms!=null) {
            for (int i=0;i<mMissingFollowingTerms.size();i++) {
                SmSequenceType xt = (SmSequenceType) mMissingFollowingTerms.get(i);
                String t = xt.formatAsSequenceType(nc);
                handler.startElement(MISSING_FOLLOWING ,null,null);
                handler.attribute(TYPE_ATTR,t,null);
                handler.endElement(MISSING_FOLLOWING,null,null);
            }
        }
    }

    public static ExpandedName makeName(String localName)
    {
        return ExpandedName.makeName(NAMESPACE,localName);
    }

    private static final ExpandedName COMPUTED_TYPE = makeName("computed-type");
    private static final ExpandedName EXPECTED_TYPE = makeName("expected-type");
    private static final ExpandedName FORMULA_TYPE = makeName("formula-type");
    private static final ExpandedName COMPLETE = makeName("complete");
    private static final ExpandedName MISSING = makeName("missing");
    private static final ExpandedName MISSING_FOLLOWING = makeName("missing-following");
    private static final ExpandedName ERRORS = makeName("errors");
    private static final ExpandedName STRUCTURAL_ERROR = makeName("structural-error");
    private static final ExpandedName REFERENCED_SCHEMA_ERROR = makeName("referenced-schema-error");
    private static final ExpandedName CONTEXT_ERROR = makeName("context-error");
    private static final ExpandedName CONTEXT_CARDINALITY_ERROR = makeName("context-cardinality-error");
    private static final ExpandedName STRUCTURAL_MOVE_TO = makeName("structural-move-to");
    private static final ExpandedName MOVE_TO = makeName("move-to");
    private static final ExpandedName RENAME_TO = makeName("rename-to");
    private static final ExpandedName REPORT_NAME = makeName("report");

    private static final ExpandedName TYPE_ATTR = ExpandedName.makeName("type");
    private static final ExpandedName MOVED_TO_ATTR = ExpandedName.makeName("moved-to");
    private static final ExpandedName NAME_ATTR = ExpandedName.makeName("name");
    private static final ExpandedName EXPLICIT_NIL_ATTR = ExpandedName.makeName("nil");
    //private static final ExpandedName COPY_NIL_ATTR = ExpandedName.makeName("copy-nil");

    /**
     * For formatting on virtual element/virtual attribute; if has an implicit 'if' around the element/attribute.
     */
    private static final ExpandedName COPY_MODE_ATTR = ExpandedName.makeName("copy-mode");
    private static final ExpandedName TYPE_COPY_OF_ATTR = ExpandedName.makeName("type-copy-of");
    private static final ExpandedName NAMESPACE_ATTR = ExpandedName.makeName("namespace");

    private void formatChildren(XmlContentHandler handler, NamespaceContextRegistry extraNamespaces) throws SAXException {
        int cc = getChildCount();
        for (int i=0;i<cc;i++) {
            getChild(i).formatFragment(handler,extraNamespaces);
        }
    }

    private void formatErrors(StringBuffer toBuffer)
    {
        ErrorMessage[] allErrors = mFormulaErrors.getMessages();
        for (int i=0;i<allErrors.length;i++) {
            if (i>0) toBuffer.append(',');
            toBuffer.append(allErrors[i]);
        }
        /*if (!isRecursivelyErrorFree()) {
            toBuffer.append(" incomplete");
        }*/
        if (mContext==null || mChildContext==null) {
            toBuffer.append("<<< error -- has null context >>>");
        }
    }
}

