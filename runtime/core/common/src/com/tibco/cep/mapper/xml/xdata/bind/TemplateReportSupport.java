package com.tibco.cep.mapper.xml.xdata.bind;

import java.util.ArrayList;
import java.util.Iterator;

import org.xml.sax.SAXException;

import com.tibco.cep.mapper.util.ResourceBundleManager;
import com.tibco.cep.mapper.xml.nsutils.NamespaceManipulationUtils;
import com.tibco.cep.mapper.xml.xdata.bind.fix.BindingFixerChange;
import com.tibco.cep.mapper.xml.xdata.bind.virt.MarkerBinding;
import com.tibco.cep.mapper.xml.xdata.xpath.EvalTypeInfo;
import com.tibco.cep.mapper.xml.xdata.xpath.Expr;
import com.tibco.cep.mapper.xml.xdata.xpath.ExprAndErrors;
import com.tibco.cep.mapper.xml.xdata.xpath.ExprContext;
import com.tibco.cep.mapper.xml.xdata.xpath.MessageCode;
import com.tibco.cep.mapper.xml.xdata.xpath.expr.TypeChecker;
import com.tibco.cep.mapper.xml.xdata.xpath.func.TibExtFunctions;
import com.tibco.xml.channel.infoset.XmlContentHandler;
import com.tibco.xml.data.primitive.ExpandedName;
import com.tibco.xml.data.primitive.NamespaceContextRegistry;
import com.tibco.xml.data.primitive.NamespaceToPrefixResolver;
import com.tibco.xml.schema.SmCardinality;
import com.tibco.xml.schema.SmParticleTerm;
import com.tibco.xml.schema.SmSequenceType;
import com.tibco.xml.schema.SmSequenceTypeRemainder;
import com.tibco.xml.schema.SmType;
import com.tibco.xml.schema.SmWildcard;
import com.tibco.xml.schema.xtype.SMDT;
import com.tibco.xml.schema.xtype.SmSequenceTypeFactory;
import com.tibco.xml.schema.xtype.helpers.SmSequenceTypeSupport;
import com.tibco.xml.tns.parse.TnsError;
import com.tibco.xml.tns.parse.TnsErrorSeverity;

/**
 * Replacement for BindingReport.
 * Generated by a Binding (template), this contains the computed types & error messages
 * for a Binding's formula.  A report applies to a single Binding & describes what is going to do, any errors that apply
 * to it, etc.
 */
public final class TemplateReportSupport
{
    public static final void initParsedFormula(TemplateReport report, TemplateReportFormulaCache formulaCache, TemplateReportArguments args)
    {
        initParsedFormula(report,formulaCache,args,false);
    }

    public static final void initParsedFormula(TemplateReport report, TemplateReportFormulaCache formulaCache, TemplateReportArguments args, boolean doBooleanCheck)
    {
        if (report.getContext()==null) {
            throw new NullPointerException("Null context on report passed in");
        }
        String formula = report.getBinding().getFormula();
        if (formula==null)
        {
            formula = "";
        }
        // go ahead & parse it:
        ExprAndErrors c = formulaCache.getParsedFormula(formula);
        Expr expr = c.getExpr();
        report.setXPathExpression(expr);
        report.addFormulaErrors(c.getErrorMessageList());

        EvalTypeInfo info = new EvalTypeInfo();
        info.setRecordErrors(true);
        /* too expensive, calculate along the way... ExprContext contextWithNs = report.getContext().createWithNamespaceMapper(
                report.getBinding().asXiNode()
        );*/
        SmSequenceType type = expr.evalType(report.getContext(),info);
        if (type==null)
        {
            throw new NullPointerException("Null returned from eval type on " + expr);
        }
        if (doBooleanCheck)
        {
            if (args==null)
            {
                throw new NullPointerException("Null args & boolean check");
            }
            info.addErrors(TypeChecker.checkConversion(type,SMDT.BOOLEAN,expr.getTextRange(),args.getXPathCheckArguments()));
        }
        if (args.getSuggestOptimizations())
        {
            CheckForOptimization.checkForOptimization(report);
        }
        report.setFormulaType(type);
        report.addFormulaErrors(info.getErrors());
    }

    public static final void initParsedAVTFormula(TemplateReport report, boolean allowNull)
    {
        if (report.getContext()==null)
        {
            throw new NullPointerException("Null context on report passed in");
        }
        String formula = report.getBinding().getFormula();
        if (!allowNull && formula==null)
        {
            formula = "";
        }
        if (formula!=null)
        {
            Expr expr = AVTUtilities.parseAsExpr(formula);
            //WCETODO add errors.
            report.setXPathExpression(expr);

            EvalTypeInfo info = new EvalTypeInfo();
            info.setRecordErrors(true);
//            ExprContext contextWithNs = report.getContext().createWithNamespaceMapper(BindingNamespaceManipulationUtils.createNamespaceImporter(report.getBinding()));
            SmSequenceType type = expr.evalType(report.getContext(),info);
            report.setFormulaType(type);
            report.addFormulaErrors(info.getErrors());
        }
        else
        {
            report.setXPathExpression(null);
            report.setFormulaType(null);
        }
    }

    public static void addMissingEndingTerms(TemplateReport ret, SmSequenceType expectedOutput, TemplateReportArguments args)
    {
        if (ret.getChildOutputContext()==SMDT.ANY_TYPE_CHILD_CONTENT)
        {
            // If the child output context IS the marker for any child content, then we shouldn't add markers; they would be useless (any-attribute*,any-element*)
            return;
        }
        for (;;) {
            SmSequenceTypeRemainder mt = expectedOutput.skip();
            if (mt==null)
            {
                break;
            }
            else
            {
                boolean es = SmSequenceTypeSupport.isVoid(mt.getMatched());
                if (es==true)
                {
                    expectedOutput.skip();
                    RuntimeException re = new RuntimeException();
                    re.printStackTrace(System.err); // WCETODO invariant?
                }
                if (!mt.getMatched().getIsAccountedFor())
                {
                    SmSequenceType t = mt.getMatched();
                    // Don't add text, as in mixed text, it's not useful.
                    if (!SmSequenceTypeSupport.isText(t))
                    {
                        if (args.isRecordingMissing())
                        {
                            {
                                ret.addMissingEndingTerm(t);
                            }
                        }
                        else
                        {
                            // just mark it as such & continue.
                            ret.setHasMissingEndingTerms(true);
                            break; // don't need to continue...
                        }
                    }
                }
                expectedOutput = mt.getRemainder();
            }
        }
    }

    public static SmSequenceType traverseChildren(TemplateReport parent, SmSequenceType remainingOutput, int outputValidationLevel, TemplateReportFormulaCache formulaCache, TemplateReportArguments templateReportArguments)
    {
        return traverseChildren(parent,remainingOutput,outputValidationLevel,0,formulaCache,templateReportArguments);
    }

    /**
     * Returns a potentially new expr context that has been updated for any namespace declarations on the node.<br>
     * Note that this is optimized for the case where there are no namespace decls and so the same object can be returned.
     * @return
     */
    public static ExprContext createContextForNamespaceDecls(Binding binding, ExprContext oldContext)
    {
        NamespaceContextRegistry nr = oldContext.getNamespaceMapper();
        NamespaceContextRegistry newresolver = BindingNamespaceManipulationUtils.createChildNamespaceResolver(nr,binding);
        if (newresolver==nr)
        {
            // cool, no change.
            return oldContext;
        }
        return oldContext.createWithNamespaceMapper(newresolver);
    }

    /**
     * Checks for errors/warnings on namespace & extra (non-standard) attributes defined on the node.
     */
    public static void checkNamespaceDeclsAndExtraAttributes(TemplateReport report, TemplateReportArguments arguments)
    {
        Binding b = report.getBinding();
        BindingElementInfo info = b.getElementInfo();
        if (arguments.getCheckForNestedNamespacesDeclarations())
        {
            BindingElementInfo.NamespaceDeclaration[] nd = info.getNamespaceDeclarations();
            for (int i=0;i<nd.length;i++)
            {
                //BindingElementInfo.NamespaceDeclaration n = nd[i];
                //String p = n.getPrefix();
                // WCETODO later add more sophisticated checks for overlap versus plain old.
                /*TemplateReport pr = report.getParent();
                if (pr!=null)
                {
                    //WCETODO I really ****ing hate having to catch exceptions for something like this.... totally wrong, it's not an exception! Does Map throw an exception if nothing if a key isn't found!?
                    String gotns;
                    try
                    {
                        gotns = pr.getContext().getNamespaceMapper().getNamespaceURIForPrefix(p);
                    }
                    catch (PrefixToNamespaceResolver.PrefixNotFoundException pnfe)
                    {
                        gotns = null;
                    }
                    if (gotns==null)
                    {
                        // one issue.
                    }
                }*/
                report.addExtendedError(new MovePrefixOutError());
            }
        }
        /*if (info.)
        NamespaceResolver nr = oldContext.getNamespaceMapper();
        NamespaceResolver newresolver = BindingNamespaceManipulationUtils.createChildNamespaceResolver(nr,binding);
        if (newresolver==nr)
        {
            // cool, no change.
            return oldContext;
        }
        return oldContext.createWithNamespaceMapper(newresolver);*/
    }

    /**
     * (Document me).<br>
     * Also checks the {@link CancelChecker} off of {@link TemplateReportArguments}, and if has been cancelled,
     * aborts (and returns a previous-error).
     * @param parent
     * @param remainingOutput
     * @param startAt
     * @param templateReportArguments
     * @return
     */
    public static SmSequenceType traverseChildren(TemplateReport parent, SmSequenceType remainingOutput, int outputValidationLevel, int startAt, TemplateReportFormulaCache formulaCache, TemplateReportArguments templateReportArguments) {
        ExprContext ec = parent.getChildContext();
        if (ec==null) {
            throw new RuntimeException("Child context must have been set");
        }
        SmSequenceType outputContext = parent.getChildOutputContext();
        if (outputContext==null) {
            throw new RuntimeException("Child output context must have been set");
        }
        if (parent.getInitialOutputType()==null)
        {
            throw new RuntimeException("Parent initial output type not set");
        }
        Binding[] c = parent.getBinding().getChildren();
        ExprContext currentInputContext = parent.getChildContext();

        for (int atBinding=startAt;atBinding<c.length;atBinding++)
        {
            if (templateReportArguments.getCancelChecker().hasBeenCancelled())
            {
                // cancel; abort, abort, abort.
                return SMDT.PREVIOUS_ERROR;
            }

            // Get the child and its associated XType.
            Binding child = c[atBinding];
            TemplateReport childReport;
            try {
                childReport = child.createTemplateReport(
                        parent,
                        currentInputContext,
                        remainingOutput,
                        outputContext,
                        outputValidationLevel,
                        formulaCache,
                        templateReportArguments
                );
                if (childReport==null) {
                    throw new NullPointerException("Null generated by " + child.getClass().getName());
                }
            } catch (Throwable t) { // be resilient:
                t.printStackTrace(System.err);
                if (parent!=null && parent.getChildCount()==atBinding+1) {
                    childReport = parent.getChild(atBinding);
                } else {
                    // Fill in minimal stuff for an error:
                    childReport = new TemplateReport(child,parent);
                }
                childReport.setChildContext(currentInputContext);
                childReport.setContext(currentInputContext);
                childReport.setOutputContext(parent.getOutputContext());
                childReport.setChildOutputContext(parent.getOutputContext());
                childReport.setInitialOutputType(remainingOutput);
                childReport.setStructuralError("Internal error: " + t.getMessage() + " analyzing " + child.getClass().getName());
                childReport.setRemainingOutputType(SMDT.PREVIOUS_ERROR);
                childReport.setFollowingContext(currentInputContext);
                traverseChildren(childReport,SMDT.PREVIOUS_ERROR,outputValidationLevel,formulaCache,templateReportArguments);
            }
            if (templateReportArguments.getCancelChecker().hasBeenCancelled())
            {
                return SMDT.PREVIOUS_ERROR;
            }
            remainingOutput = childReport.getRemainingOutputType();
            if (remainingOutput==null) {
                throw new NullPointerException("Null remaining output after " + child);
            }
            currentInputContext = childReport.getFollowingContext();
            if (currentInputContext==null) {
                throw new NullPointerException("Null following context after " + child.getClass().getName());
            }
        }
        return remainingOutput;
    }

    /**
     * Traverses expected no children; any children are marked as errors.
     * @param parent
     */
    public static void traverseNoChildren(TemplateReport parent, boolean allowComments, TemplateReportFormulaCache formulaCache, TemplateReportArguments args) {
        ExprContext ec = parent.getChildContext();
        if (ec==null) {
            throw new RuntimeException("Child context must have been set");
        }
        SmSequenceType coutputContext = parent.getChildOutputContext();
        if (coutputContext==null)
        {
            throw new RuntimeException("Child output context must have been set");
        }
        SmSequenceType outputContext = parent.getOutputContext();
        if (outputContext==null)
        {
            throw new RuntimeException("Output context must have been set");
        }
        Binding[] c = parent.getBinding().getChildren();

        for (int atBinding=0;atBinding<c.length;atBinding++)
        {
            if (args.getCancelChecker().hasBeenCancelled())
            {
                break;
            }
            Binding child = c[atBinding];
            generateReportNoChildren(allowComments,false, child, parent, formulaCache, args);
        }
    }

    /**
     * Generates a default error report for when no children (or this particular child) isn't allowed in the context.
     * @param parent
     */
    public static void generateReportNoChildren(boolean allowComments, boolean allowsSomeStatements, Binding child, TemplateReport parent, TemplateReportFormulaCache formulaCache, TemplateReportArguments args)
    {
        SmSequenceType remainingOutput = SMDT.PREVIOUS_ERROR;
        boolean err = true;
        if (allowComments && child instanceof CommentBinding)
        {
            err = false;
        }
        TemplateReport childReport = new TemplateReport(child,parent);
        childReport.setChildContext(parent.getChildContext());
        childReport.setContext(parent.getChildContext());
        childReport.setOutputContext(parent.getChildOutputContext());
        childReport.setChildOutputContext(parent.getChildOutputContext());
        childReport.setInitialOutputType(remainingOutput);
        if (err)
        {
            if (!allowsSomeStatements)
            {
                childReport.setStructuralError("No statements may appear here");
            }
            else
            {
                childReport.setStructuralError("This statement may not appear here");
            }
        }
        else
        {
            childReport.setIsRecursivelyErrorFree(true);
        }
        childReport.setRemainingOutputType(SMDT.PREVIOUS_ERROR);
        if (child instanceof MarkerBinding)
        {
            // For markers, we can still fill in the computed type, however nonsensical (this is an invariant for markers)
            childReport.setComputedType(((MarkerBinding)child).getMarkerType());
        }
        traverseChildren(childReport,SMDT.PREVIOUS_ERROR,SmWildcard.SKIP,formulaCache,args);
    }

    /*private static void initHasChildContent(TemplateReport report)
    {
        TemplateReport[] child = report.getChildren();
        boolean hasCC = false;
        for(int i=0; i < child.length; i++)
        {
            if (child[i].getHasContent())
            {
                hasCC = true;
                break;
            }
        }
        report.setHasChildContent(hasCC);
    }*/

    /**
     *
     * @param report BindingReport to initialize.
     */
    public static void initIsRecursivelyErrorFree(TemplateReport report)
    {
        if (isNodeErrorFree(report)) {
            report.setIsRecursivelyErrorFree(computeIsRecursivelyErrorFreeChildren(report));
        } else {
            report.setIsRecursivelyErrorFree(false);
        }
    }

    private static boolean computeIsRecursivelyErrorFreeChildren(TemplateReport tr)
    {
        int cc = tr.getChildCount();
        for (int i=0;i<cc;i++) {
            TemplateReport child = tr.getChild(i);
            if (!child.isRecursivelyErrorFree())
            {
                return false;
            }
            if (child.getHasMissingPrecedingTerms())
            {
                return false;
            }
        }
        return true;
    }

    /**
     * Returns true if the error condition was set (initialized).
     */
    private static boolean isNodeErrorFree(TemplateReport report)
    {
        // Do NOT check getHasMissingPrecedingTerms here ---- that's an error on the parent, not this node!
        if (report.getOutputContext()==null)
        {
            throw new IllegalArgumentException("Null output context");
        }
        if (report.getChildOutputContext()==null)
        {
            throw new IllegalArgumentException("Null child output context");
        }
        return (
                report.getFormulaErrors().getErrorAndWarningCount() ==0 &&
                report.getStructuralError()==null &&
                report.getReferencedSchemaError()==null &&
                report.getFormulaErrors().getMarkerCount()==0 &&
                report.getOutputContextError()==null &&
                report.getIsMissing()==false &&
                report.hasExtendedErrors()==false &&
                !report.getHasMissingEndingTerms() &&
                !report.getHasMissingFollowingTerms()
                );
    }

    public static TemplateReport generateStructuralErrorReport(TemplateReport parent, SmSequenceType expectedOutput, Binding child, ExprContext context, String errMessage)
    {
        TemplateReport t = new TemplateReport(child,parent);
        t.setInitialOutputType(expectedOutput);
        t.setContext(context);
        t.setOutputContext(SMDT.PREVIOUS_ERROR);
        t.setChildOutputContext(SMDT.PREVIOUS_ERROR);
        t.setChildContext(context);
        t.setRemainingOutputType(SMDT.PREVIOUS_ERROR);
        t.setStructuralError(errMessage);
        for (int i=0;i<child.getChildCount();i++)
        {
            Binding gc = child.getChild(i);
            generateStructuralErrorReport(t,expectedOutput,gc,context,null);
        }
        return t;
    }

    public static TemplateReport getLastChild(TemplateReport report) {
        int cc = report.getChildCount();
        if (cc==0) {
            return null;
        }
        return report.getChild(cc-1);
    }

    public static TemplateReport getPrecedingSibling(TemplateReport report) {
        TemplateReport p = report.getParent();
        if (p==null) {
            return null;
        }
        int ioc = p.getIndexOfChild(report);
        if (ioc>0) {
            return p.getChild(ioc-1);
        }
        return null;
    }

    public static TemplateReport getFollowingSibling(TemplateReport report)
    {
        TemplateReport p = report.getParent();
        if (p==null)
        {
            return null;
        }
        int ioc = p.getIndexOfChild(report);
        if (ioc<p.getChildCount()-1)
        {
            return p.getChild(ioc+1);
        }
        return null;
    }

    private static TemplateReport getPrecedingAncestor(TemplateReport report) {
        TemplateReport p = report.getParent();
        if (p==null)
        {
            return null;
        }
        int ioc = p.getIndexOfChild(report);
        if (ioc>0)
        {
            return p.getChild(ioc-1);
        }
        // return the parent.
        return p;
    }

    public static TemplateReport getPrecedingAncestorWithDifferentInitialOutput(TemplateReport report, SmSequenceType remainingOutput) {
        TemplateReport at = report;
        while (at!=null) {
            at = getPrecedingAncestor(at);
            if (at!=null) {
                if (at.getInitialOutputType()!=remainingOutput) {
                    return at;
                }
            }
        }
        return null;
    }

    /**
     * Gets reports that either are markers or have missing preceding BEFORE the specified report.
     * @return An array, possibly zero length of missing reports.
     */
    private static TemplateReport[] getMissingPrecedingOrMarkers(TemplateReport report)
    {
        ArrayList temp = new ArrayList();
        TemplateReport at = report;
        while (at!=null)
        {
            at = getMissingPrecedingOrMarkersInternal(at,temp);
        }
        return (TemplateReport[]) temp.toArray(new TemplateReport[0]);
    }

    private static TemplateReport getMissingPrecedingOrMarkersInternal(TemplateReport report, ArrayList list) {
        if (report.getMissingPrecedingTerms().length>0 || report.getBinding() instanceof MarkerBinding)
        {
            list.add(report);
        }
        TemplateReport p = report.getParent();
        if (p==null)
        {
            return null;
        }
        int ioc = p.getIndexOfChild(report);
        if (ioc>0)
        {
            return p.getChild(ioc-1);
        }
        return null; //?
    }

    /**
     * Adds the skipped terms to the report, either as following or as ending terms.
     * @param report
     * @param skipTo
     * @param remainder
     * @param addAsFollowing
     */
    public static void addMissingCases(TemplateReport report, SmSequenceType skipTo, SmSequenceType remainder, boolean addAsFollowing)
    {
        SmSequenceType[] getSkippedTermsTo = remainder.getSkippedTermsTo(skipTo);
        for (int i=0;i<getSkippedTermsTo.length;i++)
        {
            // add this as missing --- it's not handled in all cases:
            SmSequenceType t = getSkippedTermsTo[i];
            if (t.quantifier().getMinOccurs()>0 && !t.getIsAccountedFor())
            {
                // Don't add text, as in mixed text, it's not useful.
                if (!SmSequenceTypeSupport.isText(t))
                {
                    if (addAsFollowing)
                    {
                        report.addMissingFollowingTerm(t);
                    }
                    else
                    {
                        report.addMissingEndingTerm(t);
                    }
                    report.setIsRecursivelyErrorFree(false); // it might have been true before...
                }
            }
        }
    }

    public static SmSequenceType skipMissingPreceding(SmSequenceType type, SmSequenceType[] skip)
    {
        if (skip==null)
        {
            return type;
        }
        for (int i=0;i<skip.length;i++)
        {
            SmSequenceTypeRemainder r = type.getRemainingAfterType(skip[i],true);
            if (r==null)
            {
                return SMDT.VOID;
            }
            type = r.getRemainder();
        }
        return type;
    }

    private static class HasNoEffectError implements TemplateReportExtendedError
    {
        public static final HasNoEffectError INSTANCE = new HasNoEffectError();

        private HasNoEffectError()
        {
        }

        public boolean canFix(TemplateReport onReport)
        {
            return false;
        }

        public void fix(TemplateReport report)
        {
        }

        public int getCategory()
        {
            return BindingFixerChange.CATEGORY_WARNING;
        }

        public void formatFragment(XmlContentHandler handler, NamespaceToPrefixResolver resolver) throws SAXException
        {
            handler.startElement(NAME,null,null);
            handler.endElement(NAME,null,null);
        }

        public String formatMessage(TemplateReport report)
        {
            return ResourceBundleManager.getMessage(MessageCode.STATEMENT_HAS_NO_EFFECT);
        }

        public void registerNamespaces(NamespaceContextRegistry nsContextRegistry)
        {
        }

        private static final ExpandedName NAME = TibExtFunctions.makeName("has-no-effect");
    }

    private static class MovePrefixOutError implements TemplateReportExtendedError
    {
        public static final MovePrefixOutError INSTANCE = new MovePrefixOutError();

        private MovePrefixOutError()
        {
        }

        public boolean canFix(TemplateReport onReport)
        {
            return true;
        }

        public int getCategory()
        {
            // it is just a warning.
            return BindingFixerChange.CATEGORY_WARNING;
        }

        public void fix(TemplateReport report)
        {
            // Does all at once now...
            NamespaceManipulationUtils.bubbleOutNamespaceDeclarationsToRoot(report.getBinding().asXiNode(),BindingNodePrefixRenamer.INSTANCE);
        }

        public void formatFragment(XmlContentHandler handler, NamespaceToPrefixResolver resolver) throws SAXException
        {
            handler.startElement(NAME,null,null);
            handler.endElement(NAME,null,null);
        }

        public String formatMessage(TemplateReport report)
        {
            // like anyone is going to understand this...
            return "Namespace declaration can be moved to root.";//WCETODO resourceize.
        }

        public void registerNamespaces(NamespaceContextRegistry nsContextRegistry)
        {
        }

        private static final ExpandedName NAME = TibExtFunctions.makeName("move-prefix-out");
    }

    /**
     * Checks the given type for schema component errors, if any found, adds the first to the
     * report as an {@link TemplateReportExtendedError}, otherwise does nothing.
     * @param report The report to which errors should be added.
     * @param type The type to check, should have {@link SmSequenceType#getParticleTerm} non-null, otherwise nothing will ever happen.
     */
    public static void checkSchemaComponentErrors(TemplateReport report, SmSequenceType type)
    {
        TnsError err = getFirstSchemaComponentError(type);
        if (err!=null)
        {
            String msg = ResourceBundleManager.getMessage(MessageCode.REFERENCED_SCHEMA_ERROR,err.getMessage());
            report.setReferencedSchemaError(msg);
        }
    }

    private static TnsError getFirstSchemaComponentError(SmSequenceType type)
    {
        SmParticleTerm t = type.getParticleTerm();
        if (t!=null)
        {
            Iterator errs = t.getErrors(TnsErrorSeverity.ERROR,false);
            if (errs.hasNext())
            {
                return (TnsError) errs.next();
            }
        }
        SmType tt = SmSequenceTypeSupport.getActualElementType(type);
        if (tt!=null)
        {
            Iterator errs2 = tt.getErrors(TnsErrorSeverity.ERROR,false);
            if (errs2.hasNext())
            {
                return (TnsError) errs2.next();
            }
        }
        return null;
    }

    /**
     * Checks that there's actually <something> (anything) useful inside of this, otherwise calls {@link #addHasNoEffectError}.<br>
     * This should be called as a final error check on statements that only affect control flow but themselves give no
     * output (i.e. if, for-each, for-each-group, etc.)
     */
    public static void checkChildrenForContentAddWarning(TemplateReport report)
    {
        if (!checkChildrenForContent(report))
        {
            addHasNoEffectError(report);
        }
    }

    /**
     * Indicates if there's actually <something> (anything) useful inside of this.
     */
    public static boolean checkChildrenForContent(TemplateReport report)
    {
        for (int i=0;i<report.getChildCount();i++)
        {
            Binding c = report.getChild(i).getBinding();
            if (c instanceof TemplateContentBinding && !(c instanceof CommentBinding))
            {
                // ok, we found something that's doing <something>
                return true;
            }
        }
        return false;
    }

    /**
     * Issues a warning that the statement doesn't actually do anything useful.
     * @param report The report to add the warning to.
     */
    public static void addHasNoEffectError(TemplateReport report)
    {
        // there's nothing here, issue a warning:
        report.addExtendedError(HasNoEffectError.INSTANCE);
    }

    /**
     * Performs a match
     * Sets the {@link TemplateReport#setRemainingOutputType(com.tibco.xml.schema.SmSequenceType)} and
     * the {@link TemplateReport#setOutputContextError(boolean)}, and, if found,
     * {@link TemplateReport#setExpectedType}.
     * @param report The report to work off of & update.
     * @param outputMatcher The output matcher
     */

    /**
     * Performs a match
     * Sets the {@link TemplateReport#setRemainingOutputType} and
     * the {@link TemplateReport#setOutputContextError}, and, if found,
     * {@link TemplateReport#setExpectedType}.
     * @param report The report to work off of & update.
     * @param outputToMatch The output type that is to be matched.
     * @param fullRepetitionMatch If the output should be assumed to match all repetitions (i.e. Would OrderLine* consume all OrderLine* lines or leave a remaining OrderLine*)
     */
    public static void initForOutputMatch(TemplateReport report, SmSequenceType outputToMatch, boolean fullRepetitionMatch, TemplateReportArguments args)
    {
        SmSequenceType remainingType = report.getInitialOutputType();
        if (remainingType==null)
        {
            throw new NullPointerException("Initial output type must have been set");
        }
        if (SmSequenceTypeSupport.isPreviousError(remainingType))
        {
            // Don't add further errors....
            report.setRemainingOutputType(remainingType);
            report.setOutputContextError(null);
            return;
        }
        // Iterate over expected output attempting to match using the matcher; record any output that we skipped.
        SmSequenceType skipped = null;
        for (;;)
        {
            SmSequenceTypeRemainder remainingIfMatch = remainingType.getRemainingAfterType(outputToMatch,fullRepetitionMatch);
            if (remainingIfMatch!=null)
            {
                remainingType = remainingIfMatch.getRemainder();
                skipped = remainingIfMatch.getSkipped();
                report.setExpectedType(remainingIfMatch.getMatched());
                break;
            }
            else
            {
                // out of place...
                break;
            }
        }
        if (report.getExpectedType()==null)
        {
            // We didn't find a match:
            remainingType = report.getInitialOutputType();

            TemplateReport lc = TemplateReportSupport.getPrecedingAncestorWithDifferentInitialOutput(report,report.getInitialOutputType());
            if (lc!=null && lc.getInitialOutputType().getRemainingAfterType(outputToMatch,fullRepetitionMatch)!=null)
            {
                report.setOutputContextError(TemplateOutputContextError.CARDINALITY);
            }
            else
            {
                if (SmSequenceTypeSupport.isText(outputToMatch) || SmSequenceTypeSupport.isValueType(outputToMatch))
                {
                    // Refine the message a bit:
                    report.setOutputContextError(TemplateOutputContextError.UNEXPECTED_TEXT);
                }
                else
                {
                    report.setOutputContextError(TemplateOutputContextError.UNEXPECTED);
                }
            }
        }
        else
        {
            // We DID find a match:
            report.setOutputContextError(null);
            if (report.getOutputContext()!=SMDT.ANY_TYPE_CHILD_CONTENT) // If the output context IS the marker for any child content, then we shouldn't add markers; they would be useless (any-attribute*,any-element*)
            {
                addSkippedPreviousTerms(skipped, report, args);
            }
        }
        report.setRemainingOutputType(remainingType);
    }

    /**
     * Adds any skipped terms to the report.
     * @param skipped
     * @param report
     * @param args
     */
    private static void addSkippedPreviousTerms(SmSequenceType skipped, TemplateReport report, TemplateReportArguments args)
    {
        if (!SmSequenceTypeSupport.isVoid(skipped))
        {
            // ... but before we found that match, we had to skip some terms, record those:
            for (int i=0;;i++)
            {
                SmSequenceTypeRemainder skip;
                for (;;)
                {
                    SmSequenceTypeRemainder tskip = skipped.skip();
                    if (tskip==null)
                    {
                        skip = null;
                        break;
                    }
                    if (SmSequenceTypeSupport.isVoid(tskip.getMatched()))
                    {
                        skipped = tskip.getRemainder();
                    }
                    else
                    {
                        skip = tskip;
                        break;
                    }
                }
                if (skip==null)
                {
                    break;
                }
                boolean isMissing = true;
                SmSequenceType skippedTerm = skip.getMatched();
                skipped = skip.getRemainder();
                if (!skippedTerm.getIsAccountedFor())
                {
                    if (i==0)
                    {
                        TemplateReport preceeding = TemplateReportSupport.getPrecedingSibling(report);
                        // Of those terms, do a quick check that something hasn't already been renamed.
                        if (preceeding!=null && preceeding.getRenameTo()!=null && preceeding.getRenameTo().equals(SmSequenceTypeSupport.getElementOrAttributeName(skippedTerm)))
                        {
                            // do not add, it has already been renamed.
                            isMissing = false;
                        }
                    }
                    if (isMissing)
                    {
                        report.setHasMissingPrecedingTerms(true);
                        if (args.isRecordingMissing())
                        {
                            // If we need to, explicitly record it (o.w. not)
                            report.addMissingPrecedingTerm(skippedTerm);
                        }
                    }
                }
            }
        }
    }

    /**
     * For constructs like xsl:if, xsl:for-each, it makes sense that markers indicating missing preceding terms
     * appear before the construct, rather than inside of it.<br>
     * This method applies that fixup.<br>
     * Note that xsl:choose cannot use this; it is more complicated by the fact that it needs to check multiple paths.
     * @param report The report of the construct like xsl:if.
     */
    public static void bubbleOutMissingPrecedingTerms(TemplateReport report)
    {
        SmSequenceType initialOutput = report.getInitialOutputType();
        // Bubble-out the preceding missing terms (better to put in front of the 'if')
        for (int i=0;i<report.getChildCount();i++) {
            TemplateReport tr = report.getChild(i);
            if (tr.getInitialOutputType()!=initialOutput)
            {
                break;
            }
            if (tr.getHasMissingPrecedingTerms())
            {
                report.setHasMissingPrecedingTerms(true);
                // don't explicitly check the 'save missing terms' ---- if they are saved before, just copy:
                SmSequenceType[] t = tr.getMissingPrecedingTerms();
                for (int ti=0;ti<t.length;ti++)
                {
                    report.addMissingPrecedingTerm(t[ti]);
                }
                tr.removeAllMissingPrecedingTerms();
                break;
            }
        }
    }

    /**
     * For constructs like xsl:if, xsl:for-each, etc., it makes sense that if the content inside is in the wrong spot
     * that the control surrounding it moves.<br>
     * This method applies that fixup.<br>
     * @param firstContent The firstContent content being created, or null if none (if null, this function does nothing).
     * @param parent The parent report of report.
     * @param report The report to check.
     */
    public static void bubbleOutMove(TemplateReport firstContent, TemplateReport parent, TemplateReport report)
    {
        if (firstContent!=null && firstContent.getOutputContextError()!=null && firstContent.getOutputContextError().getHadSchemaComponent())
        {
            {
                SmSequenceType outputType = firstContent.getComputedType();
                if (TemplateReportSupport.extendedMatchForReorder(parent, report, outputType, false))
                {
                    report.setOutputContextError(firstContent.getOutputContextError());

                    // bubble up output context error:
                    firstContent.setOutputContextError(null);

                    TemplateReportSupport.initIsRecursivelyErrorFree(firstContent); // recompute this.
                }
            }
        }
    }

    /**
     * Does a check for and schedules renames for a namespace change.
     * @return true if there was a namespace change; if so a rename will be set on the report.
     */
    public static boolean extendedMatchForNamespaceChange(TemplateReport report, SmSequenceType namespacefreeOutput, boolean fullRepetitionMatch)
    {
        SmSequenceType remainingType = report.getInitialOutputType();
        for (;;) {
            // First try any namespace name:
            SmSequenceTypeRemainder remainingIfMatch = remainingType.getRemainingAfterType(namespacefreeOutput,fullRepetitionMatch);
            if (remainingIfMatch!=null)
            {
                SmSequenceType match = SmSequenceTypeSupport.removeUnnamed(remainingIfMatch.getMatched());
                ExpandedName ename = SmSequenceTypeSupport.getElementOrAttributeName(getFirstMatchingInChoice(match,namespacefreeOutput));
                if (ename!=null)
                {
                    // can be null if we matched a wildcard or something...
                    report.setRenameTo(ename);
                    return true;
                }
                break;
            } else {
                SmSequenceTypeRemainder remainder = remainingType.skip();
                // add skipped...
                if (remainder==null) {
                    // can't match...
                    break;
                }
                remainingType = remainder.getRemainder();
            }
        }
        return false;
    }

    /**
     * Does a check for and schedules renames for a namespace change; same as {@link TemplateReportSupport#extendedMatchForNamespaceChange}
     * except that this just modifies (improves) the error message rather than suggesting a rename (since you can't really rename a copy-of -- the left
     * hand side is the problem).
     * @return true if there was a namespace change; if so a rename will be set on the report.
     */
    public static boolean extendedMatchForNamespaceChangeNonDataComponent(TemplateReport report, SmSequenceType namespacefreeOutput, boolean fullRepetitionMatch)
    {
        SmSequenceType remainingType = report.getInitialOutputType();
        for (;;) {
            // First try any namespace name:
            SmSequenceTypeRemainder remainingIfMatch = remainingType.getRemainingAfterType(namespacefreeOutput,fullRepetitionMatch);
            if (remainingIfMatch!=null)
            {
                SmSequenceType match = SmSequenceTypeSupport.removeUnnamed(remainingIfMatch.getMatched());
                ExpandedName ename = SmSequenceTypeSupport.getElementOrAttributeName(TemplateReportSupport.getFirstMatchingInChoice(match,namespacefreeOutput));
                if (ename!=null)
                {
                    // Ok, it was just a ns-mismatch, refine the error message:
                    report.setOutputContextError(TemplateOutputContextError.UNEXPECTED_NS_MISMATCH);
                    return true;
                }
                break;
            } else {
                SmSequenceTypeRemainder remainder = remainingType.skip();
                if (remainder==null) {
                    // can't match...
                    break;
                }
                remainingType = remainder.getRemainder();
            }
        }
        return false;
    }


    /**
     * Because {@link SmSequenceType#getRemainingAfterType} returns the entire choice when matching a choice, we must
     * step through & match the specific choice that matched.
     * @param type The candidate choice or sequence type
     * @param mtype The type to match against.
     * @return The matching type, or type if no match.
     */
    public static SmSequenceType getFirstMatchingInChoice(SmSequenceType type, SmSequenceType mtype)
    {
        SmSequenceType tp = type.prime();
        int tc = tp.getTypeCode();
        if (tc==SmSequenceType.TYPE_CODE_CHOICE || tc==SmSequenceType.TYPE_CODE_SEQUENCE)
        {
            SmSequenceType[] choices = SmSequenceTypeSupport.getAllChoices(tp);
            for (int i=0;i<choices.length;i++)
            {
                SmSequenceTypeRemainder r = choices[i].getRemainingAfterType(mtype,true);
                if (r!=null)
                {
                    return getFirstMatchingInChoice(r.getMatched(),mtype);
                }
            }
        }
        return tp;
    }

    /**
     * Based on the report's children, computes the output XType of the template body.<br>
     * This is useful, for example, for computing the output of a variable (not using select).
     * @param parent
     * @return The xtype, never null.
     */
    public static SmSequenceType computeProducedOutput(TemplateReport parent)
    {
        SmSequenceType sofar = SMDT.VOID;
        for (int i=0;i<parent.getChildCount();i++)
        {
            TemplateReport ch = parent.getChild(i);
            SmSequenceType item = SMDT.VOID;
            if (ch.getComputedType()!=null && !SmSequenceTypeSupport.isVoid(ch.getComputedType()))
            {
                item = ch.getComputedType();
            }
            else
            {
                Binding b = ch.getBinding();
                //WCETODO need a better test for this:
                if (b instanceof IfBinding)
                {
                    item = computeProducedOutput(ch);
                    if (!SmSequenceTypeSupport.isVoid(item))
                    {
                        item = SmSequenceTypeFactory.createRepeats(item,SmCardinality.OPTIONAL).simplify(false);
                    }
                }
                if (b instanceof ForEachBinding || b instanceof ForEachGroupBinding)
                {
                    item = computeProducedOutput(ch);
                    if (!SmSequenceTypeSupport.isVoid(item))
                    {
                        item = SmSequenceTypeFactory.createRepeats(item,SmCardinality.REPEATING).simplify(false);
                    }
                }
                if (b instanceof ChooseBinding || b instanceof WhenBinding || b instanceof OtherwiseBinding)
                {
                    //WCETODO not implemented yet...
                }
            }
            sofar = SmSequenceTypeFactory.createSimplifiedSequence(sofar,item);
        }
        return sofar;
    }

    /**
     * Finds first child of the parent which produces any output.
     */
    public static TemplateReport findFirstOutputProducingChild(TemplateReport parent)
    {
        for (int i=0;i<parent.getChildCount();i++)
        {
            TemplateReport ch = parent.getChild(i);
            if (ch.getComputedType()!=null && !SmSequenceTypeSupport.isVoid(ch.getComputedType()))
            {
                return ch;
            }
            Binding b = ch.getBinding();
            //WCETODO need a better test for this:
            if (b instanceof IfBinding || b instanceof ChooseBinding || b instanceof WhenBinding || b instanceof OtherwiseBinding || b instanceof ForEachBinding || b instanceof ForEachGroupBinding)
            {
                TemplateReport r = findFirstOutputProducingChild(ch);
                if (r!=null)
                {
                    return r;
                }
            }
        }
        return null;
    }

    /**
     * Computes the term, if any, build in the content.
     * @param report The report, i.e. for a for-each binding.
     * @return The type or null if cannot be computed or ambiguous.
     */
    public static SmSequenceType getMatchedChildTerm(TemplateReport report)
    {
        // Find all matched terms:
        SmSequenceType sofar = null;
        for (int i=0;i<report.getChildCount();i++)
        {
            TemplateReport rc = report.getChild(i);
            if (rc.getExpectedType()!=null)
            {
                if (sofar!=null)
                {
                    // more than 1 term, yuck. WCETODO figure out what to do here... this works for most cases, but
                    // anon. sequences it won't.
                    return null;
                }
                sofar = rc.getExpectedType();
            }
        }
        return sofar;
    }

    public static boolean extendedMatchForReorder(TemplateReport parent, TemplateReport report, SmSequenceType outputToMatch, boolean fullRepetitionMatch)
    {
        TemplateReport[] previousReports = TemplateReportSupport.getMissingPrecedingOrMarkers(TemplateReportSupport.getLastChild(parent));

        // Look for movement, search for 'unfilled' areas before us.
        for (int i=previousReports.length-1;i>=0;i--) // Search from bottom-to-top assuming that closer means more probable.
        {
            // First match missing preceding terms:
            TemplateReport previousReport = previousReports[i];
            SmSequenceType[] missing = previousReport.getMissingPrecedingTerms();
            for (int j=0;j<missing.length;j++) {
                SmSequenceType t = missing[j];
                if (previousReport.getPrecedingMovedFrom(j)==null)
                {
                    // only move 1 thing there.
                    SmSequenceTypeRemainder r = t.getRemainingAfterType(outputToMatch,fullRepetitionMatch);
                    if (r!=null)
                    {
                        // cool it, matched:
                        previousReport.setMovedFrom(j,report); // whatever...
                        report.setMovedToMissingPreceding(previousReport,j);
                        return true;
                    }
                }
            }
            // Now trying the marker itself (if it is one)
            if (previousReport.getBinding() instanceof MarkerBinding)
            {
                MarkerBinding mb = (MarkerBinding) previousReport.getBinding();
                SmSequenceTypeRemainder r = mb.getMarkerType().getRemainingAfterType(outputToMatch,fullRepetitionMatch);
                if (r!=null)
                {
                    // also cool, it matched:
                    previousReport.setMovedFrom(-1,report); // whatever...
                    report.setMovedToMissingPreceding(previousReport,-1);
                    return true;
                }
            }
        }
        return false;
    }

    public static boolean fixupExtraOtherwiseOnChildren(TemplateReport parent)
    {
        return fixupExtraOtherwiseOnChildren(parent,parent);
    }

    private static boolean fixupExtraOtherwiseOnChildren(TemplateReport root, TemplateReport parent)
    {
        for (int i=0;i<parent.getChildCount();i++)
        {
            TemplateReport ch = parent.getChild(i);
            SmSequenceType[] t = ch.getMissingFollowingTerms();
            if (t.length>0)
            {
                SmSequenceType lt = t[t.length-1]; // only applies to last term (usually 1, though)
                if (lt.quantifier().getMaxOccurs()>1)
                {
                    // if max occurs is not >1, do not allow stuff after it to count; the choose or if must
                    // entirly 'eat' this term.
                    if (scanForFollowingTerm(parent,i+1,lt,ch.getRemainingOutputType()))
                    {
                        ch.removeLastMissingFollowingTerms();
                        recomputeErrorFree(ch, root);
                    }
                }
            }
            if (ch.getChildCount()>0)
            {
                if (ch.getChild(0).getInitialOutputType()==ch.getInitialOutputType())
                {
                    // Recurse inside things that don't change initial output type (i.e. elements)
                    fixupExtraOtherwiseOnChildren(root,ch);
                }
            }
        }
        return false;
    }

    private static void recomputeErrorFree(TemplateReport ch, TemplateReport root)
    {
        TemplateReport at = ch;
        while (at!=root)
        {
            boolean ef = TemplateReportSupport.isNodeErrorFree(at);
            if (ef)
            {
                TemplateReportSupport.initIsRecursivelyErrorFree(at);
                if (at.isRecursivelyErrorFree())
                {
                    at = at.getParent();
                }
                else
                {
                    break;
                }
            }
            else
            {
                break;
            }
        }
    }

    private static boolean scanForFollowingTerm(TemplateReport parent, int childIndex, SmSequenceType searchFor, SmSequenceType scanTo)
    {
        for (int at=childIndex;at<parent.getChildCount();at++)
        {
            TemplateReport next = parent.getChild(at);
            SmSequenceType ct = next.getComputedType();
            if (ct!=null)
            {
                if (searchFor.getRemainingAfterType(ct,true)!=null)
                {
                    return true; // ha, found it.
                }
            }
            if (next.getChildCount()>0)
            {
                if (scanForFollowingTerm(next,0,searchFor,scanTo))
                {
                    return true;
                }
            }
            if (next.getRemainingOutputType()!=scanTo)
            {
                // hit something else, stop searching.
                return false;
            }
        }
        TemplateReport pp = parent.getParent();
        if (pp==null)
        {
            return false;
        }
        int ioc = pp.getIndexOfChild(parent);
        return scanForFollowingTerm(pp,ioc+1,searchFor,scanTo);
    }
}

