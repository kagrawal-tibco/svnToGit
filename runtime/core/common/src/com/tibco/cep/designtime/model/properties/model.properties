## DependencyAnalyzer stuff ##
DependencyAnalyzer.analyzeError = Error while Analyzing: Skipping Rule {0}

#### AbstractEntityView Properties ###
# Error when adding a reference to an MutableEntity into an EntityView that already contains such a reference
AbstractEntityView.addEntityReference.error = {0} already contains a reference to {1}

### AbstractEntity Properties ###
# Passing in an invalid name
AbstractEntity.setName.emptyString = Empty and null Strings are invalid names
AbstractEntity.setName.nameConflict = An Entity with name {0} already exists in Folder {1}
AbstractEntity.setName.badName = {0} is not a valid Java Identifier

### AbstractEntityLink Properties ###
AbstractEntityLink.create.nullViewOrNodes = An Entity Link cannot be created with null endpoints or a null MutableEntity View

### AbstractEntityReference Properties ###
AbstractEntityReference.setEntityPath.pathExists = The view already contains a reference to the entity {0}

### AbstractCompilable ###
AbstractCompilable.errors.missingEntity = Cannot find the type {0} for identifier {1} 

### DefaultMutableChannel ###
DefaultMutableChannel.setDriver.badDriverName = Bad Driver Name
DefaultMutableChannel.setDriver.nullDriver = Driver is Null

### DefaultMutableConcept ###
DefaultMutableConcept.createPropertyDefinition.badRDFType = Bad RDF Type
DefaultMutableConcept.createPropertyDefinition.duplicateName = A Property Definition with name {0} already exists in {1}.
DefaultMutableConcept.setSuper.inheritPropertyConflict = {0} cannot inherit from {1} because they have a Property Definition name in common.
DefaultMutableConcept.setSuper.inheritanceLoop = {0} cannot inherit from {1} because an inheritance loop will be created.
DefaultMutableConcept.createPropertyDefinition.maxPropertyDefinitions = Could not create {0}: A Concept can have at most {1} Local Property Definitions.
DefaultMutableConcept.createPropertyDefinition.nullConceptType = Could not find Concept: {0}
DefaultMutableConcept.createPropertyDefinition.conceptTypeAlreadyContained = Concept {0} is already contained by {1}
DefaultMutableConcept.createPropertyDefinition.selfContainedConcept = A Concept cannot contain itself
DefaultMutableConcept.createPropertyDefinition.containmentCircle = {0} is already contained by {1}
DefaultMutableConcept.errors.superConceptIsNull = {0} could not find super Concept {1}
DefaultMutableConcept.errors.propertyConceptMissing = {0} has a property named {1} that could not find {2}


### DefaultFolder ###
DefaultFolder.setName.cantNameRootFolder = The Root Folder cannot be renamed
DefaultFolder.setName.nameConflict = A Folder with name {0} already exists in Folder {1}

### DefaultPropertyDefinition ###
DefaultPropertyDefinition.setName.nameConflict = A Property Definition with name {0} already exists in Concept {1}

### DefaultEvent ###
DefaultEvent.setSuperEventPath.inheritPropertyConflict = {0} cannot inherit from {1} because they have a User Property ({2}) in common.
DefaultEvent.setSuperEventPath.nonAbstractInheritance = Cannot derive from Event with payload: {0}
DefaultEvent.addUserProperty.clobber.title = Clobbering A User Property
DefaultEvent.addUserProperty.clobber.msg = Property {0} already exists on Event {1}
DefaultEvent.addUserProperty.override.title = Clobbering A User Property
DefaultEvent.addUserProperty.override.msg = Cannot clobber: Property {0} already exists on Event {1}
DefaultEvent.setPayload.isAbstract.msg = Abstract Event {0} cannot have a payload...
DefaultEvent.setDestination.noDefaultDest.msg = A Default Destination is not specified...

######################## State Machine Errors ########################

### DefaultStateComposite ###
DefaultStateComposite.getModelErrors.compositesMustHaveOneStartState = Composite States must contain exactly one Start MutableState.
DefaultStateComposite.getModelErrors.concurrentStateMustContainTwoRegions = A Concurrent MutableState must contain at least two regions.
DefaultMutableStateComposite.getModelErrors.allSubstatesOfConcurrentMustBeComposites = All sub-states of a Concurrent State must be Composite States (Regions).
DefaultMutableStateComposite.getModelErrors.regionsMustHaveOneEndState = Regions must have at least one End State.

### DefaultStateDecoration ###
DefaultStateComposite.getModelErrors.decorationsMustHaveABoundingRectangleSet = Decorations must have a bounding rectangle set.

### DefaultStateEntity ###
DefaultStateEntity.unknownError = Unknown Error.
DefaultStateEntity.canStart.endStateCannotHaveExitingTransitions = An End State cannot have exiting transitions.

### DefaultStateMachine ###
DefaultStateMachine.canAddOne.endStatesCannotHaveExitingTransitions = End States cannot have exiting transitions.
DefaultStateMachine.canAddOne.pseudoStatesCannotHaveExitingTransitions = Pseudo States cannot have exiting transitions.
DefaultStateMachine.canAddOne.startStatesCannotHaveEnteringTransitions = Start States cannot have entering transitions.
DefaultStateMachine.canAddOne.rootStateCannotHaveEnteringOrExitingTransitions = The Root State cannot have entering or exiting transitions.
DefaultStateMachine.canAddOne.cantCreateTransitionThatExitsRegion = Can't create a transition that exits from a Concurrent State Region.
DefaultStateMachine.canAddOne.cantCreateTransitionThatEntersRegion = Can't create a transition that enters a Concurrent State Region.
DefaultStateMachine.canDeleteOne.cantDeleteStartStateFromRoot = Can't delete Start MutableState from State Machine root.
DefaultStateMachine.canDeleteOne.rootMustContainOneEndState = The MutableState Machine Root must contain at least one End State.
DefaultStateMachine.canDeleteOne.regionsMustContainOneEndState = Concurrent MutableState Regions must contain at least one End State.
DefaultStateMachine.canDeleteOne.regionsCannotBeDeletedWhenTheyContainStatesOtherThanStartAndEnd = Only Regions that contain only Start and End States can be deleted.
DefaultStateMachine.canDeleteOne.concurrentStatesMustAlwaysContainTwoRegions = Concurrent States must always contain at least two Regions.
DefaultStateMachine.getModelErrors.stateMachineOwnerConceptMustBeSet = State Machine's Owner Concept must be set (not null).
DefaultStateMachine.getModelErrors.stateMachineMustHaveARootState = The State Machine must have a root state.
DefaultStateMachine.getModelErrors.rootMustNotHaveParent = The State Machine's root state must not be contained in any other state (must not have a parent).
DefaultStateMachine.validateTransitionOrigin.endStateCannotHaveExitingTransitions = End States cannot have exiting transitions.
DefaultStateMachine.validateTransitionOrigin.cantCreateATransitionStartingFromARegion = Can't draw a transition starting from a Region.

### DefaultStateSubmachine ###
DefaultStateSubmachine.getModelErrors.submachinesMustHaveAPathSet = Submachines must have a path set.
DefaultStateSubmachine.getModelErrors.submachinesCannotBeConcurrentStates = Submachines cannot be Concurrent States.
DefaultStateSubmachine.getModelErrors.submachinesCanOnlyContainStubStates = Submachines can have only Stub States as sub-states.

### DefaultStateTransition ###
DefaultStateTransition.getModelErrors.transitionMustHaveFromState = Transition must have a 'from' State.
DefaultStateTransition.getModelErrors.transitionMustHaveToState = Transition must have a 'to' State.
DefaultStateTransition.getModelErrors.endStateCannotHaveExitingTransitions = An End State cannot have exiting transitions.
DefaultStateTransition.getModelErrors.startStateCannotHaveEnteringTransitions = A Start State cannot have entering transitions.
DefaultStateTransition.getModelErrors.rootStateCannotHaveExitingTransitions = The Root State cannot have an exiting transition.
DefaultStateTransition.getModelErrors.rootStateCannotHaveEnteringTransitions = The Root State cannot have an entering transition.
DefaultStateTransition.getModelErrors.transitionExitingPseudoStateCannotHaveGuardRule = A transition exiting a Pseudo State cannot have a guard rule
DefaultStateTransition.getModelErrors.lambdaSelfTransition = A Transition from a State to itself must have a condition

### DefaultState ###
DefaultState.getModelErrors.multipleLambdas = A MutableState should not have multiple lamda/empty condition transitions originating from it.
DefaultState.getModelErrors.timeoutStateMissing = Specified Timeout Policy requires a timeout state

##### Classes that currently don't have errors #####
### DefaultStateAnnotationLink ###
### DefaultStateEnd ###
### DefaultStateGroupBox ###
### DefaultStateLink ###
### DefaultStatePseudo ###
### DefaultStateRectangle ###
### DefaultStateRoundedRectangle ###
### DefaultStateSimple ###
### DefaultStateStart ###
### DefaultStateTextDecoration ###
### DefaultStateTextLabel ###
### DefaultStateVertex ###
